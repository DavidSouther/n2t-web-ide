{"version":3,"file":"static/js/949.f3039c73.chunk.js","mappings":"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","sources":["../../components/src/difftable.tsx","../../simulator/src/chip/chip.tsx","../../simulator/src/chip/clock.ts","../../simulator/src/cpu/alu.ts","../../simulator/src/cpu/cpu.ts","../../simulator/src/cpu/memory.ts","../../simulator/src/fs.ts","../../simulator/src/languages/base.ts","../../simulator/src/languages/grammars/base.ohm.js","../../simulator/src/languages/grammars/cmp.ohm.js","../../simulator/src/languages/cmp.ts","../../simulator/src/languages/grammars/tst.ohm.js","../../simulator/src/languages/tst.ts","../../simulator/src/languages/grammars/vm.ohm.js","../../simulator/src/languages/vm.ts","../../simulator/src/languages/grammars/asm.ohm.js","../../simulator/src/languages/asm.ts","../../simulator/src/loader.ts","../../simulator/src/output.ts","../../simulator/src/test/instruction.ts","../../simulator/src/test/builder.ts","../../simulator/src/test/chiptst.ts","../../simulator/src/test/cputst.ts","../../simulator/src/test/tst.ts","../../simulator/src/test/vmtst.ts","../../simulator/src/util/asm.ts","../../simulator/src/util/twos.ts","../../simulator/src/vm/memory.ts","../../simulator/src/vm/vm.ts"],"sourcesContent":["import { CMP } from \"@nand2tetris/simulator/languages/cmp.js\";\nimport { display } from \"@davidsouther/jiffies/lib/esm/display.js\";\nimport { range } from \"@davidsouther/jiffies/lib/esm/range.js\";\nimport { Err, isErr, Ok } from \"@davidsouther/jiffies/lib/esm/result.js\";\nimport { ReactElement } from \"react\";\n\nexport const DiffTable = ({\n  className = \"\",\n  out,\n  cmp,\n  zeroState,\n}: {\n  out: string;\n  cmp: string;\n  className?: string;\n  zeroState?: ReactElement;\n}) => {\n  const output = CMP.parse(out);\n  const compare = CMP.parse(cmp);\n\n  if (isErr(output)) {\n    return (\n      <details>\n        <summary>Failed to parse output</summary>\n        <pre>{display(Err(output))}</pre>\n        <code>\n          <pre>{out}</pre>\n        </code>\n      </details>\n    );\n  }\n\n  if (isErr(compare)) {\n    return (\n      <details>\n        <summary>Failed to parse compare</summary>\n        <code>\n          <pre>{display(Err(compare))}</pre>\n          <pre>{cmp}</pre>\n        </code>\n      </details>\n    );\n  }\n\n  const cmpData = Ok(compare);\n  const outData = Ok(output);\n  let failures = 0;\n  const table = range(0, Math.min(cmpData.length, outData.length)).map((i) => {\n    const cmpI = cmpData[i] ?? [];\n    const outI = outData[i] ?? [];\n    return range(0, Math.max(cmpI.length, outI.length))\n      .map((_, j) => [cmpI[j] ?? \"\", outI[j] ?? \"\"])\n      .map(([cmp, out]) => {\n        const cell = {\n          cmp: cmp ?? '\"',\n          out: out ?? '\"',\n          pass:\n            cmp?.trim().match(/^\\*+$/) !== null || out?.trim() === cmp?.trim(),\n        };\n        if (!cell.pass) {\n          failures += 1;\n        }\n        return cell;\n      });\n  });\n\n  return (\n    <div className={\"scroll-x \" + className}>\n      {failures > 0 && (\n        <p>\n          {failures} failure{failures === 1 ? \"\" : \"s\"}\n        </p>\n      )}\n      {table.length > 0 ? (\n        <table\n          style={{\n            fontFamily: \"var(--font-family-monospace)\",\n            marginBottom: \"none\",\n          }}\n        >\n          <tbody>\n            {table.map((row, i) => (\n              <tr key={i}>\n                {row.map(({ cmp, out, pass }, i) => (\n                  <DiffCell cmp={cmp} out={out} pass={pass} key={i} />\n                ))}\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      ) : (\n        zeroState ?? <p>Execute test script to compare output.</p>\n      )}\n    </div>\n  );\n};\n\nconst DiffCell = ({\n  cmp,\n  out,\n  pass,\n}: {\n  cmp: string;\n  out: string;\n  pass: boolean;\n}) => {\n  return pass ? (\n    <>\n      <td>{cmp}</td>\n    </>\n  ) : (\n    <>\n      <td>\n        <ins>{cmp}</ins>\n        <br />\n        <del>{out}</del>\n      </td>\n    </>\n  );\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { assert, assertExists } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport { range } from \"@davidsouther/jiffies/lib/esm/range.js\";\nimport { bin } from \"../util/twos.js\";\nimport { Clock } from \"./clock.js\";\n\nexport const HIGH = 1;\nexport const LOW = 0;\nexport type Voltage = typeof HIGH | typeof LOW;\n\nexport interface Pin {\n  readonly name: string;\n  readonly width: number;\n  busVoltage: number;\n  pull(voltage: Voltage, bit?: number): void;\n  toggle(bit?: number): void;\n  voltage(bit?: number): Voltage;\n  connect(pin: Pin): void;\n}\n\nexport class Bus implements Pin {\n  state: Voltage[];\n  next: Pin[] = [];\n\n  constructor(readonly name: string, readonly width = 1) {\n    this.state = range(0, this.width).map(() => LOW);\n  }\n\n  ensureWidth(newWidth: number) {\n    assert(newWidth <= 16, `Cannot widen past 16 to ${newWidth} bits`);\n    if (this.width < newWidth) {\n      (this as { width: number }).width = newWidth;\n      this.state = [\n        ...this.state,\n        ...range(this.width, newWidth).map(() => LOW as Voltage),\n      ];\n    }\n  }\n\n  connect(next: Pin) {\n    this.next.push(next);\n    next.busVoltage = this.busVoltage;\n  }\n\n  pull(voltage: Voltage, bit = 0) {\n    assert(\n      bit >= 0 && bit < this.width,\n      `Bit out of bounds: ${this.name}@${bit}`\n    );\n    this.state[bit] = voltage;\n    this.next.forEach((n) => n.pull(voltage, bit));\n  }\n\n  voltage(bit = 0): Voltage {\n    assert(bit >= 0 && bit < this.width);\n    return this.state[bit];\n  }\n\n  set busVoltage(voltage: number) {\n    for (const i of range(0, this.width)) {\n      this.state[i] = ((voltage & (1 << i)) >> i) as Voltage;\n    }\n    this.next.forEach((n) => (n.busVoltage = this.busVoltage));\n  }\n\n  get busVoltage(): number {\n    return range(0, this.width).reduce((b, i) => b | (this.state[i] << i), 0);\n  }\n\n  toggle(bit = 0) {\n    const nextVoltage = this.voltage(bit) === LOW ? HIGH : LOW;\n    this.pull(nextVoltage, bit);\n  }\n}\n\nexport class InSubBus extends Bus {\n  constructor(\n    private bus: Pin,\n    private start: number,\n    override readonly width = 1\n  ) {\n    super(bus.name);\n    assert(\n      start >= 0 && start + width <= bus.width,\n      `Mismatched InSubBus dimensions on ${bus.name} (${width} + ${start} > ${bus.width})`\n    );\n    this.connect(bus);\n  }\n\n  override pull(voltage: Voltage, bit = 0) {\n    assert(bit >= 0 && bit < this.width);\n    this.bus.pull(voltage, this.start + bit);\n  }\n\n  override voltage(bit = 0): Voltage {\n    assert(bit >= 0 && bit < this.width);\n    return this.bus.voltage(this.start + bit);\n  }\n\n  override set busVoltage(voltage: number) {\n    const high = this.bus.busVoltage & ~mask(this.width + this.start);\n    const low = this.bus.busVoltage & mask(this.start);\n    const mid = (voltage & mask(this.width)) << this.start;\n    this.bus.busVoltage = high | mid | low;\n  }\n\n  override get busVoltage(): number {\n    return (this.bus.busVoltage >> this.start) & mask(this.width);\n  }\n\n  override connect(bus: Pin): void {\n    assert(\n      this.start + this.width <= bus.width,\n      `Mismatched InSubBus connection dimensions (From ${bus.name} to ${this.name})`\n    );\n    this.bus = bus;\n  }\n}\n\nexport class OutSubBus extends Bus {\n  constructor(\n    private bus: Pin,\n    private start: number,\n    override readonly width = 1\n  ) {\n    super(bus.name);\n    assert(start >= 0 && width <= bus.width, `Mismatched OutSubBus dimensions`);\n    this.connect(bus);\n  }\n\n  override set busVoltage(voltage: number) {\n    this.bus.busVoltage =\n      (voltage & mask(this.width + this.start)) >> this.start;\n  }\n\n  override get busVoltage(): number {\n    return this.bus.busVoltage & mask(this.width);\n  }\n\n  override connect(bus: Pin): void {\n    assert(\n      this.width <= bus.width,\n      `Mismatched OutSubBus connection dimensions`\n    );\n    this.bus = bus;\n  }\n}\n\nexport class ConstantBus extends Bus {\n  constructor(name: string, private readonly value: number) {\n    super(name, 16 /* TODO: get high bit index */);\n  }\n\n  pullHigh(_ = 0) {\n    return undefined;\n  }\n  pullLow(_ = 0) {\n    return undefined;\n  }\n  override voltage(_ = 0): Voltage {\n    return (this.busVoltage & 0x1) as Voltage;\n  }\n\n  override set busVoltage(voltage: number) {\n    // Noop\n  }\n  override get busVoltage(): number {\n    return this.value;\n  }\n}\n\nexport const TRUE_BUS = new ConstantBus(\"true\", 0xffff);\nexport const FALSE_BUS = new ConstantBus(\"false\", 0);\n\nexport function parsePinDecl(toPin: string): {\n  pin: string;\n  width: number;\n} {\n  const { pin, w } = toPin.match(/(?<pin>[a-zA-Z]+)(\\[(?<w>\\d+)\\])?/)\n    ?.groups as {\n    pin: string;\n    w?: string;\n  };\n  return {\n    pin,\n    width: w ? Number(w) : 1,\n  };\n}\n\nexport function parseToPin(toPin: string): {\n  pin: string;\n  start?: number;\n  end?: number;\n} {\n  const { pin, i, j } = toPin.match(\n    /(?<pin>[a-z]+)(\\[(?<i>\\d+)(\\.\\.(?<j>\\d+))?\\])?/\n  )?.groups as { pin: string; i?: string; j?: string };\n  return {\n    pin,\n    start: i ? Number(i) : undefined,\n    end: j ? Number(j) : undefined,\n  };\n}\n\nexport class Pins {\n  private readonly map = new Map<string, Pin>();\n\n  insert(pin: Pin) {\n    const { name } = pin;\n    assert(!this.map.has(name), `Pins already has ${name}!`);\n    this.map.set(name, pin);\n  }\n\n  emplace(name: string, minWidth?: number) {\n    if (this.has(name)) {\n      return this.get(name)!;\n    } else {\n      const pin = new Bus(name, minWidth);\n      this.insert(pin);\n      return pin;\n    }\n  }\n\n  has(pin: string): boolean {\n    return this.map.has(pin);\n  }\n\n  get(pin: string): Pin | undefined {\n    return this.map.get(pin);\n  }\n\n  entries(): Iterable<Pin> {\n    return this.map.values();\n  }\n\n  [Symbol.iterator]() {\n    return this.map[Symbol.iterator]();\n  }\n}\n\nlet id = 0;\nexport class Chip {\n  readonly id = id++;\n  ins = new Pins();\n  outs = new Pins();\n  pins = new Pins();\n  parts = new Set<Chip>();\n  clockedPins: Set<string>;\n\n  get clocked() {\n    if (this.clockedPins.size > 0) {\n      return true;\n    }\n    for (const part of this.parts) {\n      if (part.clocked) return true;\n    }\n    return false;\n  }\n\n  constructor(\n    ins: (string | { pin: string; width: number })[],\n    outs: (string | { pin: string; width: number })[],\n    public name?: string,\n    internals: (string | { pin: string; width: number })[] = [],\n    clocked: string[] = []\n  ) {\n    for (const inn of ins) {\n      const { pin, width = 1 } =\n        (inn as { pin: string }).pin !== undefined\n          ? (inn as { pin: string; width: number })\n          : parsePinDecl(inn as string);\n      this.ins.insert(new Bus(pin, width));\n    }\n\n    for (const out of outs) {\n      const { pin, width = 1 } =\n        (out as { pin: string }).pin !== undefined\n          ? (out as { pin: string; width: number })\n          : parsePinDecl(out as string);\n      this.outs.insert(new Bus(pin, width));\n    }\n\n    for (const internal of internals) {\n      const { pin, width = 1 } =\n        (internal as { pin: string }).pin !== undefined\n          ? (internal as { pin: string; width: number })\n          : parsePinDecl(internal as string);\n      this.pins.insert(new Bus(pin, width));\n    }\n\n    this.clockedPins = new Set(clocked);\n\n    Clock.get().$.subscribe(() => this.eval());\n  }\n\n  reset() {\n    for (const [_, pin] of this.ins) {\n      pin.busVoltage = 0;\n    }\n    for (const part of this.parts) {\n      part.reset();\n    }\n    this.eval();\n  }\n\n  in(pin = \"in\"): Pin {\n    assert(this.hasIn(pin), `No in pin ${pin}`);\n    return this.ins.get(pin)!;\n  }\n\n  out(pin = \"out\"): Pin {\n    assert(this.hasOut(pin), `No in pin ${pin}`);\n    return this.outs.get(pin)!;\n  }\n\n  hasIn(pin: string): boolean {\n    return this.ins.has(pin);\n  }\n\n  hasOut(pin: string): boolean {\n    return this.outs.has(pin);\n  }\n\n  pin(name: string): Pin {\n    assert(this.pins.has(name));\n    return this.pins.get(name)!;\n  }\n\n  get(name: string, offset?: number): Pin | undefined {\n    if (this.ins.has(name)) {\n      return this.ins.get(name)!;\n    }\n    if (this.outs.has(name)) {\n      return this.outs.get(name)!;\n    }\n    if (this.pins.has(name)) {\n      return this.pins.get(name)!;\n    }\n    return this.getBuiltin(name, offset);\n  }\n\n  private getBuiltin(name: string, offset = 0): Pin | undefined {\n    if (BUILTIN_NAMES.includes(name)) {\n      for (const part of this.parts) {\n        const pin = part.get(name, offset);\n        if (pin) {\n          return pin;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  isOutPin(pin: string): boolean {\n    return this.outs.has(pin);\n  }\n\n  wire(part: Chip, connections: Connection[]) {\n    this.parts.add(part);\n    for (const { to, from } of connections) {\n      if (part.isOutPin(to.name)) {\n        this.wireOutPin(part, to, from);\n      } else {\n        this.wireInPin(part, to, from);\n      }\n    }\n  }\n\n  private findPin(from: string, minWidth?: number): Pin {\n    if (from.toLowerCase() === \"true\" || from === \"1\") {\n      return TRUE_BUS;\n    }\n    if (from.toLowerCase() === \"false\" || from === \"0\") {\n      return FALSE_BUS;\n    }\n    if (this.ins.has(from)) {\n      return this.ins.get(from)!;\n    }\n    if (this.outs.has(from)) {\n      return this.outs.get(from)!;\n    }\n    return this.pins.emplace(from, minWidth);\n  }\n\n  private wireOutPin(part: Chip, to: PinSide, from: PinSide) {\n    const partPin = assertExists(\n      part.outs.get(to.name),\n      () => `Cannot wire to missing pin ${to.name}`\n    );\n    to.width ??= partPin.width;\n\n    let chipPin = this.findPin(from.name, from.width ?? to.width);\n    const isInternal = this.pins.has(chipPin.name);\n\n    from.width ??= chipPin.width;\n\n    if (chipPin instanceof ConstantBus) {\n      throw new Error(`Cannot wire to constant bus`);\n    }\n\n    // Widen internal pins\n    if (isInternal && chipPin instanceof Bus) {\n      chipPin.ensureWidth(from.start + from.width);\n    }\n\n    // Wrap the chipPin in an InBus when the chip side is dimensioned\n    if (from.start > 0 || from.width !== chipPin.width) {\n      chipPin = new InSubBus(chipPin, from.start, from.width);\n    }\n\n    // Wrap the chipPin in an OutBus when the part side is dimensioned\n    if (to.start > 0 || to.width !== chipPin.width) {\n      chipPin = new OutSubBus(chipPin, to.start, to.width);\n    }\n\n    partPin.connect(chipPin);\n  }\n\n  private wireInPin(part: Chip, to: PinSide, from: PinSide) {\n    let partPin = assertExists(\n      part.ins.get(to.name),\n      () => `Cannot wire to missing pin ${to.name}`\n    );\n    to.width ??= partPin.width;\n\n    const chipPin = this.findPin(from.name, from.width ?? to.width);\n\n    from.width ??= chipPin.width;\n\n    // Wrap the partPin in an InBus when the part side is dimensioned\n    if (to.start > 0 || to.width !== chipPin.width) {\n      partPin = new InSubBus(partPin, to.start, to.width);\n    }\n\n    // Wrap the partPin in an OutBus when the chip side is dimensioned\n    if (![\"true\", \"false\"].includes(chipPin.name)) {\n      if (from.start > 0 || from.width !== chipPin.width) {\n        partPin = new OutSubBus(partPin, from.start, from.width);\n      }\n    }\n    chipPin.connect(partPin);\n  }\n\n  eval() {\n    for (const chip of this.parts) {\n      // TODO topological sort\n      // eval chip input busses\n      TRUE_BUS.next.forEach((pin) => (pin.busVoltage = TRUE_BUS.busVoltage));\n      FALSE_BUS.next.forEach((pin) => (pin.busVoltage = FALSE_BUS.busVoltage));\n      chip.eval();\n      // eval output busses\n    }\n  }\n\n  tick() {\n    this.eval();\n  }\n\n  tock() {\n    this.eval();\n  }\n\n  remove() {\n    for (const part of this.parts) {\n      part.remove();\n    }\n  }\n\n  // For the ROM32K builtin to load from a file system\n  async load(fs: FileSystem, path: string): Promise<void> {\n    for (const part of this.parts) {\n      if (part.name === \"ROM32K\") {\n        await part.load(fs, path);\n      }\n    }\n  }\n}\n\nexport class Low extends Chip {\n  constructor() {\n    super([], []);\n    this.outs.insert(FALSE_BUS);\n  }\n}\n\nexport class High extends Chip {\n  constructor() {\n    super([], []);\n    this.outs.insert(TRUE_BUS);\n  }\n}\n\nexport class ClockedChip extends Chip {\n  override get clocked(): boolean {\n    return true;\n  }\n\n  #subscription = Clock.get().$.subscribe(({ level }) => {\n    if (level === LOW) {\n      this.tock();\n    } else {\n      this.tick();\n    }\n  });\n\n  override remove() {\n    this.#subscription.unsubscribe();\n    super.remove();\n  }\n\n  override reset(): void {\n    super.reset();\n    this.tick();\n    this.tock();\n  }\n}\n\nexport interface PinSide {\n  name: string;\n  start: number;\n  width?: number;\n}\n\nexport interface Connection {\n  // To is the part side\n  to: PinSide;\n  // From is the chip side\n  from: PinSide;\n}\n\nexport type Pinout = Record<string, string>;\nexport interface SerializedChip {\n  id: number;\n  name: string;\n  ins: Pinout;\n  outs: Pinout;\n  pins: Pinout;\n  children: SerializedChip[];\n}\n\nfunction mask(width: number) {\n  return Math.pow(2, width) - 1;\n}\n\nfunction setBus(busses: Pinout, pin: Pin) {\n  busses[pin.name] = bin(\n    (pin.busVoltage & mask(pin.width)) <<\n      (pin as unknown as { start: number }).start ?? 0\n  );\n  return busses;\n}\n\nexport function printChip(chip: Chip): SerializedChip {\n  return {\n    id: chip.id,\n    name: chip.name ?? chip.constructor.name,\n    ins: [...chip.ins.entries()].reduce(setBus, {} as Pinout),\n    outs: [...chip.outs.entries()].reduce(setBus, {} as Pinout),\n    pins: [...chip.pins.entries()].reduce(setBus, {} as Pinout),\n    children: [...chip.parts.values()].map(printChip),\n  };\n}\n\nexport const BUILTIN_NAMES = [\n  \"Register\",\n  \"ARegister\",\n  \"DRegister\",\n  \"PC\",\n  \"RAM8\",\n  \"RAM64\",\n  \"RAM512\",\n  \"RAM4K\",\n  \"RAM16K\",\n  \"ROM32K\",\n  \"Screen\",\n  \"Keyboard\",\n  \"Memory\",\n];\n","import { BehaviorSubject, Observable, Subject } from \"rxjs\";\nimport { assert } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { HIGH, LOW, Voltage } from \"./chip.js\";\n\ninterface Tick {\n  readonly level: Voltage;\n  readonly ticks: number;\n}\n\nlet clock: Clock;\nexport class Clock {\n  private level: Voltage = LOW;\n  private ticks = 0;\n\n  static get() {\n    if (clock === undefined) {\n      clock = new Clock();\n    }\n    return clock;\n  }\n\n  get isHigh(): boolean {\n    return this.level === HIGH;\n  }\n\n  get isLow(): boolean {\n    return this.level === LOW;\n  }\n\n  private subject = new BehaviorSubject<Tick>({\n    level: this.level,\n    ticks: this.ticks,\n  });\n  readonly frameSubject = new Subject<void>();\n  readonly resetSubject = new Subject<void>();\n\n  readonly $: Observable<Tick> = this.subject;\n  readonly frame$: Observable<void> = this.frameSubject;\n  readonly reset$: Observable<void> = this.resetSubject;\n\n  private next() {\n    this.subject.next({\n      level: this.level,\n      ticks: this.ticks,\n    });\n  }\n\n  private constructor() {\n    // private\n  }\n\n  reset() {\n    this.level = LOW;\n    this.ticks = 0;\n    this.next();\n    this.resetSubject.next();\n  }\n\n  tick() {\n    assert(this.level === LOW, \"Can only tick up from LOW\");\n    this.level = HIGH;\n    this.next();\n  }\n\n  tock() {\n    assert(this.level === HIGH, \"Can only tock down from HIGH\");\n    this.level = LOW;\n    this.ticks += 1;\n    this.next();\n  }\n\n  toggle() {\n    this.level === HIGH ? this.tock() : this.tick();\n  }\n\n  eval() {\n    this.tick();\n    this.tock();\n  }\n\n  frame() {\n    this.frameSubject.next();\n  }\n\n  toString() {\n    return `${this.ticks}${this.level === HIGH ? \"+\" : \"\"}`;\n  }\n}\n","export type COMMANDS_ASM =\n  | \"0\"\n  | \"1\"\n  | \"-1\"\n  | \"D\"\n  | \"A\"\n  | \"M\"\n  | \"!D\"\n  | \"!A\"\n  | \"-D\"\n  | \"-A\"\n  | \"D+1\"\n  | \"A+1\"\n  | \"D-1\"\n  | \"A-1\"\n  | \"D+A\"\n  | \"D-A\"\n  | \"D-M\"\n  | \"A-D\"\n  | \"D&A\"\n  | \"D&M\"\n  | \"D|A\"\n  | \"D|M\";\n\nexport type COMMANDS_OP =\n  | 0b101010\n  | 0b111111\n  | 0b111010\n  | 0b001100\n  | 0b110000\n  | 0b110000\n  | 0b001101\n  | 0b110001\n  | 0b001111\n  | 0b110011\n  | 0b011111\n  | 0b110111\n  | 0b001110\n  | 0b110010\n  | 0b000010\n  | 0b010011\n  | 0b010011\n  | 0b000111\n  | 0b000000\n  | 0b000000\n  | 0b010101\n  | 0b010101;\n\n//Usefull for the visualization of the ALU\nexport type COMMANDS_ALU =\n  | \"0\"\n  | \"1\"\n  | \"-1\"\n  | \"x\"\n  | \"y\"\n  | \"!x\"\n  | \"!y\"\n  | \"-x\"\n  | \"-y\"\n  | \"x+1\"\n  | \"y+1\"\n  | \"x-1\"\n  | \"y-1\"\n  | \"x+y\"\n  | \"x-y\"\n  | \"y-x\"\n  | \"x&y\"\n  | \"x|y\";\n\nexport const COMMANDS_ALU: {\n  op: Record<COMMANDS_OP, COMMANDS_ALU>;\n} = {\n  op: {\n    0x2a: \"0\",\n    0x3f: \"1\",\n    0x3a: \"-1\",\n    0x0c: \"x\",\n    0x30: \"y\",\n    0x0d: \"!x\",\n    0x31: \"!y\",\n    0x0f: \"-x\",\n    0x33: \"-y\",\n    0x1f: \"x+1\",\n    0x37: \"y+1\",\n    0x0e: \"x-1\",\n    0x32: \"y-1\",\n    0x02: \"x+y\",\n    0x13: \"x-y\",\n    0x07: \"y-x\",\n    0x00: \"x&y\",\n    0x15: \"x|y\",\n  },\n};\n\nexport const COMMANDS: {\n  asm: Record<COMMANDS_ASM, COMMANDS_OP>;\n  op: Record<COMMANDS_OP, COMMANDS_ASM>;\n} = {\n  asm: {\n    \"0\": 0b101010, // 42 0x2A\n    \"1\": 0b111111, // 63 0x3F\n    \"-1\": 0b111010, // 58 0x3A\n    D: 0b001100, // 12 0x0C\n    A: 0b110000, // 48 0x30\n    M: 0b110000, // 48 0x30\n    \"!D\": 0b001101, // 13 0x0D\n    \"!A\": 0b110001, // 49 0x31\n    \"-D\": 0b001111, // 15 0x0F\n    \"-A\": 0b110011, // 51 0x33\n    \"D+1\": 0b011111, // 31 0x1F\n    \"A+1\": 0b110111, // 55 0x37\n    \"D-1\": 0b001110, // 14 0x0E\n    \"A-1\": 0b110010, // 50 0x32\n    \"D+A\": 0b000010, //  2 0x02\n    \"D-A\": 0b010011, // 19 0x13\n    \"D-M\": 0b010011, // 19 0x13\n    \"A-D\": 0b000111, //  7 0x07\n    \"D&A\": 0b000000, //  0 0x00\n    \"D&M\": 0b000000, //  0 0x00\n    \"D|A\": 0b010101, // 21 0x15\n    \"D|M\": 0b010101, // 21 0x15\n  },\n  op: {\n    0x2a: \"0\",\n    0x3f: \"1\",\n    0x3a: \"-1\",\n    0x0c: \"D\",\n    0x30: \"A\",\n    0x0d: \"!D\",\n    0x31: \"!A\",\n    0x0f: \"-D\",\n    0x33: \"-A\",\n    0x1f: \"D+1\",\n    0x37: \"A+1\",\n    0x0e: \"D-1\",\n    0x32: \"A-1\",\n    0x02: \"D+A\",\n    0x13: \"D-A\",\n    0x07: \"A-D\",\n    0x00: \"D&A\",\n    0x15: \"D|A\",\n  },\n};\n\nexport type ASSIGN_ASM = \"\" | \"M\" | \"D\" | \"MD\" | \"A\" | \"AM\" | \"AD\" | \"AMD\";\nexport type ASSIGN_OP = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\n\nexport const ASSIGN: {\n  asm: Record<ASSIGN_ASM, ASSIGN_OP>;\n  op: Record<ASSIGN_OP, ASSIGN_ASM>;\n} = {\n  asm: {\n    \"\": 0x0,\n    M: 0b001,\n    D: 0b010,\n    MD: 0b011,\n    A: 0b100,\n    AM: 0b101,\n    AD: 0b110,\n    AMD: 0b111,\n  },\n  op: {\n    0x0: \"\",\n    0x1: \"M\",\n    0x2: \"D\",\n    0x3: \"MD\",\n    0x4: \"A\",\n    0x5: \"AM\",\n    0x6: \"AD\",\n    0x7: \"AMD\",\n  },\n};\n\nexport type JUMP_ASM =\n  | \"\"\n  | \"JGT\"\n  | \"JEQ\"\n  | \"JGE\"\n  | \"JLT\"\n  | \"JNE\"\n  | \"JLE\"\n  | \"JMP\";\nexport type JUMP_OP = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\nexport const JUMP: {\n  asm: Record<JUMP_ASM, JUMP_OP>;\n  op: Record<JUMP_OP, JUMP_ASM>;\n} = {\n  asm: {\n    \"\": 0b0,\n    JGT: 0b001,\n    JEQ: 0b010,\n    JGE: 0b011,\n    JLT: 0b100,\n    JNE: 0b101,\n    JLE: 0b110,\n    JMP: 0b111,\n  },\n  op: {\n    0x0: \"\",\n    0x1: \"JGT\",\n    0x2: \"JEQ\",\n    0x3: \"JGE\",\n    0x4: \"JLT\",\n    0x5: \"JNE\",\n    0x6: \"JLE\",\n    0x7: \"JMP\",\n  },\n};\n\nexport const Flags = {\n  0x01: \"Positive\",\n  0x00: \"Zero\",\n  0x0f: \"Negative\",\n  Positive: 0x01,\n  Zero: 0x00,\n  Negative: 0x0f,\n};\n\nexport function alu(op: number, d: number, a: number): [number, number] {\n  let o = 0;\n  switch (op) {\n    case 0x2a:\n      o = 0;\n      break;\n    case 0x3f:\n      o = 1;\n      break;\n    case 0x3a:\n      o = -1;\n      break;\n    case 0x0c:\n      o = d;\n      break;\n    case 0x30:\n      o = a;\n      break;\n    case 0x0d:\n      o = ~d;\n      break;\n    case 0x31:\n      o = ~a;\n      break;\n    case 0x0f:\n      o = -d;\n      break;\n    case 0x33:\n      o = -a;\n      break;\n    case 0x1f:\n      o = d + 1;\n      break;\n    case 0x37:\n      o = a + 1;\n      break;\n    case 0x0e:\n      o = d - 1;\n      break;\n    case 0x32:\n      o = a - 1;\n      break;\n    case 0x02:\n      o = d + a;\n      break;\n    case 0x13:\n      o = d - a;\n      break;\n    case 0x07:\n      o = a - d;\n      break;\n    case 0x00:\n      o = d & a;\n      break;\n    case 0x15:\n      o = d | a;\n      break;\n  }\n\n  o = o & 0xffff;\n  const flags =\n    o === 0 ? Flags.Zero : o & 0x8000 ? Flags.Negative : Flags.Positive;\n  return [o, flags];\n}\n\nexport function alua(op: number, d: number, a: number): [number, number] {\n  if (op & 0b100000) d = 0;\n  if (op & 0b010000) d = ~d & 0xffff;\n  if (op & 0b001000) a = 0;\n  if (op & 0b000100) a = ~a & 0xffff;\n\n  let o = (op & 0b000010 ? d + a : d & a) & 0xffff;\n  if (op & 0b000001) o = ~o & 0xffff;\n\n  const flags =\n    o === 0 ? Flags.Zero : o & 0x8000 ? Flags.Negative : Flags.Positive;\n  return [o, flags];\n}\n","import { alu, COMMANDS_OP, Flags } from \"./alu.js\";\nimport {\n  Memory,\n  MemoryAdapter,\n  MemoryKeyboard,\n  SubMemory,\n  RAM as RAMMem,\n  SCREEN_OFFSET,\n  SCREEN_SIZE,\n} from \"./memory.js\";\n\nexport interface CPUInput {\n  inM: number;\n  instruction: number;\n  reset: boolean;\n}\n\nexport interface CPUOutput {\n  outM: number;\n  writeM: boolean;\n  addressM: number;\n}\n\nexport interface CPUState {\n  A: number;\n  D: number;\n  PC: number;\n  ALU: number;\n  flag: number;\n}\n\nexport function emptyState(): CPUState {\n  return { A: 0, D: 0, PC: 0, ALU: 0, flag: Flags.Zero };\n}\n\nconst BITS = {\n  c: 0b1000_0000_0000_0000,\n  x1: 0b1001_0000_0000_0000,\n  x2: 0b1001_0000_0000_0000,\n  am: 0b1001_0000_0000_0000,\n  op: 0b0000_1111_1100_0000,\n  d1: 0b1000_0000_0010_0000,\n  d2: 0b1000_0000_0001_0000,\n  d3: 0b1000_0000_0000_1000,\n  j1: 0b1000_0000_0000_0001,\n  j2: 0b1000_0000_0000_0010,\n  j3: 0b1000_0000_0000_0100,\n};\n\nexport function decode(instruction: number) {\n  function bit(bit: number): boolean {\n    return (instruction & bit) === bit;\n  }\n  const bits = {\n    c: bit(BITS.c),\n    x1: bit(BITS.x1),\n    x2: bit(BITS.x2),\n    am: bit(BITS.am),\n    op: ((instruction & BITS.op) >> 6) as COMMANDS_OP,\n    d1: bit(BITS.d1),\n    d2: bit(BITS.d2),\n    d3: bit(BITS.d3),\n    j1: bit(BITS.j1),\n    j2: bit(BITS.j2),\n    j3: bit(BITS.j3),\n  };\n\n  return bits;\n}\n\nexport function cpuTick(\n  { inM, instruction }: CPUInput,\n  { A, D, PC }: CPUState\n): [CPUState, boolean] {\n  const bits = decode(instruction);\n  const a = bits.am ? inM : A;\n  const [ALU, flag] = alu(bits.op, D, a);\n\n  return [{ A, D, PC: PC + 1, ALU, flag }, bits.d3];\n}\n\nexport function cpuTock(\n  { inM, instruction, reset }: CPUInput,\n  { A, D, PC, ALU, flag }: CPUState\n): [CPUOutput, CPUState] {\n  const bits = decode(instruction);\n\n  const j1 = bits.j1 && flag === Flags.Positive;\n  const j2 = bits.j2 && flag === Flags.Zero;\n  const j3 = bits.j3 && flag === Flags.Negative;\n  const jmp = j1 || j2 || j3;\n\n  PC = reset ? 0 : jmp ? A : PC;\n\n  if (bits.d2) {\n    D = ALU;\n  }\n\n  if (!bits.c) {\n    A = instruction & 0x7fff;\n  } else if (bits.d1) {\n    A = ALU;\n  }\n\n  const a = bits.am ? inM : A;\n  const alu2 = alu(bits.op, D, a);\n\n  ALU = alu2[0];\n  flag = alu2[1];\n\n  const output: CPUOutput = {\n    addressM: A,\n    outM: ALU,\n    writeM: bits.d3,\n  };\n\n  const state: CPUState = {\n    A,\n    D,\n    ALU,\n    flag,\n    PC,\n  };\n\n  return [output, state];\n}\n\nexport function cpu(input: CPUInput, state: CPUState): [CPUOutput, CPUState] {\n  const [tickState, _writeM] = cpuTick(input, state);\n  return cpuTock(input, tickState);\n}\n\nexport class CPU {\n  readonly RAM: Memory;\n  readonly ROM: Memory;\n  readonly Screen: MemoryAdapter;\n  readonly Keyboard: MemoryKeyboard;\n\n  #pc = 0;\n  #a = 0;\n  #d = 0;\n\n  #tickState: CPUState = {\n    A: 0,\n    D: 0,\n    PC: 0,\n    ALU: 0,\n    flag: Flags.Zero,\n  };\n\n  get state(): CPUState {\n    return this.#tickState;\n  }\n\n  get PC() {\n    return this.#pc;\n  }\n\n  get A() {\n    return this.#a;\n  }\n\n  get D() {\n    return this.#d;\n  }\n\n  setA(value: number) {\n    this.#a = value;\n  }\n\n  setD(value: number) {\n    this.#d = value;\n  }\n\n  setPC(value: number) {\n    this.#pc = value;\n  }\n\n  constructor({ RAM = new RAMMem(), ROM }: { RAM?: Memory; ROM: Memory }) {\n    this.RAM = RAM;\n    this.ROM = ROM;\n\n    // \"Device Map\"\n    this.Screen = new SubMemory(this.RAM, SCREEN_SIZE, SCREEN_OFFSET);\n    this.Keyboard = new MemoryKeyboard(this.RAM);\n  }\n\n  reset() {\n    this.#pc = 0;\n    this.#a = 0;\n    this.#d = 0;\n  }\n\n  tick() {\n    const [{ addressM, outM, writeM }, { A, D, PC }] = cpu(\n      {\n        inM: this.RAM.get(this.#a),\n        instruction: this.ROM.get(this.#pc),\n        reset: false,\n      },\n      {\n        A: this.#a,\n        D: this.#d,\n        PC: this.#pc,\n        ALU: this.#d,\n        flag: Flags.Zero,\n      }\n    );\n\n    this.#a = A;\n    this.#d = D;\n    this.#pc = PC;\n\n    if (writeM) {\n      this.RAM.set(addressM, outM);\n    }\n  }\n}\n","import { assert } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport { op } from \"../util/asm.js\";\nimport { int10, int16, int2 } from \"../util/twos.js\";\nimport { load } from \"../fs.js\";\n\nexport const FORMATS = [\"bin\", \"dec\", \"hex\", \"asm\"];\nexport type Format = typeof FORMATS[number];\n\nexport const SCREEN_OFFSET = 0x4000;\nexport const SCREEN_ROWS = 512;\nexport const SCREEN_COLS = 256;\nexport const SCREEN_SIZE = SCREEN_ROWS * SCREEN_COLS;\nexport const KEYBOARD_OFFSET = 0x6000;\n\nexport interface MemoryAdapter {\n  size: number;\n  get(index: number): number;\n  set(index: number, value: number): void;\n  update(cell: number, value: string, format: Format): void;\n  load(fs: FileSystem, path: string): Promise<void>;\n  loadBytes(bytes: number[]): void;\n  range(start?: number, end?: number): number[];\n  map<T>(\n    fn: (index: number, value: number) => T,\n    start?: number,\n    end?: number\n  ): Iterable<T>;\n  [Symbol.iterator](): Iterable<number>;\n}\n\nexport interface KeyboardAdapter {\n  getKey(): number;\n  setKey(key: number): void;\n  clearKey(): void;\n}\n\nexport class Memory implements MemoryAdapter {\n  private memory: Int16Array;\n\n  get size(): number {\n    return this.memory.length;\n  }\n\n  constructor(memory: ArrayBuffer | number) {\n    if (typeof memory === \"number\") {\n      this.memory = new Int16Array(memory);\n    } else {\n      this.memory = new Int16Array(memory);\n    }\n  }\n\n  get(index: number): number {\n    if (index < 0 || index >= this.size) {\n      return 0xffff;\n    }\n    return this.memory[index] ?? 0;\n  }\n\n  set(index: number, value: number): void {\n    if (index >= 0 && index < this.size) {\n      this.memory[index] = value & 0xffff;\n    }\n  }\n\n  reset(): void {\n    this.memory.fill(0);\n  }\n\n  update(cell: number, value: string, format: Format) {\n    let current: number;\n    switch (format) {\n      case \"asm\":\n        current = op(value);\n        break;\n      case \"bin\":\n        current = int2(value);\n        break;\n      case \"hex\":\n        current = int16(value);\n        break;\n      case \"dec\":\n      default:\n        current = int10(value);\n        break;\n    }\n\n    if (isFinite(current) && current <= 0xffff) {\n      this.set(cell, current);\n    }\n  }\n\n  async load(fs: FileSystem, path: string) {\n    try {\n      this.loadBytes(await load(fs, path));\n    } catch (cause) {\n      // throw new Error(`ROM32K Failed to load file ${path}`, { cause });\n      throw new Error(`Memory Failed to load file ${path}`);\n    }\n  }\n\n  loadBytes(bytes: number[]): void {\n    this.memory.set(new Int16Array(bytes));\n    this.memory.fill(0, bytes.length, this.size);\n  }\n\n  range(start = 0, end = this.size): number[] {\n    return [...this.memory.slice(start, end)];\n  }\n\n  *map<T>(\n    fn: (index: number, value: number) => T,\n    start = 0,\n    end = this.size\n  ): Iterable<T> {\n    assert(start <= end);\n    for (let i = start; i < end; i++) {\n      yield fn(i, this.get(i));\n    }\n  }\n\n  [Symbol.iterator](): Iterable<number> {\n    return this.map((_, v) => v);\n  }\n}\n\nexport class SubMemory implements MemoryAdapter {\n  constructor(\n    private readonly parent: MemoryAdapter,\n    readonly size: number,\n    private readonly offset: number\n  ) {}\n\n  get(index: number): number {\n    if (index < 0 || index >= this.size) {\n      return 0xffff;\n    }\n    return this.parent.get(this.offset + index);\n  }\n\n  set(index: number, value: number): void {\n    if (index >= 0 && index < this.size) {\n      this.parent.set(index + this.offset, value);\n    }\n  }\n\n  update(index: number, value: string, format: string): void {\n    if (index >= 0 && index < this.size) {\n      this.parent.update(index + this.offset, value, format);\n    }\n  }\n\n  load(fs: FileSystem, path: string): Promise<void> {\n    return this.parent.load(fs, path);\n  }\n\n  loadBytes(bytes: number[]): void {\n    return this.parent.loadBytes(bytes);\n  }\n\n  range(start?: number, end?: number): number[] {\n    return this.parent.range(start, end);\n  }\n\n  map<T>(\n    fn: (index: number, value: number) => T,\n    start = 0,\n    end: number = this.size\n  ): Iterable<T> {\n    return this.parent.map(fn, start + this.offset, end + this.offset);\n  }\n\n  [Symbol.iterator](): Iterable<number> {\n    return this.map((_, v) => v);\n  }\n}\n\nexport class MemoryKeyboard extends SubMemory implements KeyboardAdapter {\n  constructor(memory: MemoryAdapter) {\n    super(memory, 1, 0x6000);\n  }\n\n  getKey(): number {\n    return this.get(0);\n  }\n\n  setKey(key: number): void {\n    this.set(0, key & 0xffff);\n  }\n\n  clearKey(): void {\n    this.set(0, 0);\n  }\n}\n\nexport class ROM extends Memory {\n  static readonly SIZE = 0x8000;\n  constructor(program: Int16Array) {\n    const arr = new Int16Array(ROM.SIZE);\n    arr.set(program);\n    super(arr);\n  }\n}\n\nexport class RAM extends Memory {\n  keyboard = new SubMemory(this, 1, KEYBOARD_OFFSET);\n  screen = new SubMemory(this, SCREEN_SIZE, SCREEN_OFFSET);\n\n  // 4k main memory, 2k screen memory, 1 keyboard\n  // static readonly SIZE = 0x4000 + 0x2000 + 0x0001;\n  static readonly SIZE = 0x8000;\n  constructor() {\n    super(RAM.SIZE);\n  }\n}\n","import { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport * as loader from \"./loader.js\";\n\nexport async function load(fs: FileSystem, path: string): Promise<number[]> {\n  if (path.endsWith(\".hack\")) {\n    return loadHack(fs, path);\n  }\n\n  if (path.endsWith(\".asm\")) {\n    return loadAsm(fs, path);\n  }\n\n  throw new Error(`Cannot load file without hack or asm extension ${path}`);\n}\n\nexport async function loadAsm(fs: FileSystem, path: string): Promise<number[]> {\n  return loader.loadAsm(await fs.readFile(path));\n}\n\nexport async function loadHack(\n  fs: FileSystem,\n  path: string\n): Promise<number[]> {\n  return loader.loadHack(await fs.readFile(path));\n}\n","import ohm from \"ohm-js\";\nimport { int10, int16, int2 } from \"../util/twos.js\";\nimport { Err, Ok, Result } from \"@davidsouther/jiffies/lib/esm/result.js\";\n\nexport const UNKNOWN_PARSE_ERROR = `Unknown parse error`;\n\nimport baseGrammar from \"./grammars/base.ohm.js\";\nexport const grammars = {\n  Base: ohm.grammar(baseGrammar),\n};\n\nexport const baseSemantics = grammars.Base.createSemantics();\n\nbaseSemantics.extendOperation(\"asIteration\", {\n  List(list, _) {\n    return list.asIteration();\n  },\n});\n\nbaseSemantics.addAttribute(\"value\", {\n  decNumber(_, digits): number {\n    return int10(digits.sourceString);\n  },\n  wholeDec(_, digits): number {\n    return int10(digits.sourceString);\n  },\n  binNumber(_, digits) {\n    return int2(digits.sourceString);\n  },\n  hexNumber(_, digits) {\n    return int16(digits.sourceString);\n  },\n  Number(num) {\n    return num.value;\n  },\n  Name(ident) {\n    return ident.name;\n  },\n  identifier(_, __): string {\n    return this.sourceString;\n  },\n});\n\nbaseSemantics.addAttribute(\"name\", {\n  identifier(_, __): string {\n    return this.sourceString;\n  },\n  Name(_): string {\n    return this.child(0)?.name;\n  },\n});\n\nbaseSemantics.addAttribute(\"String\", {\n  String(_a, str, _b) {\n    return str.sourceString;\n  },\n});\n\nexport type ParseError = Error | { message: string; shortMessage: string };\n\nexport function makeParser<ResultType>(\n  grammar: ohm.Grammar,\n  semantics: ohm.Semantics,\n  property: (obj: ohm.Dict) => ResultType = ({ root }) => root\n): (source: string) => Result<ResultType, ParseError> {\n  return function parse(source) {\n    try {\n      const match = grammar.match(source);\n      if (match.succeeded()) {\n        const parsed = semantics(match);\n        const parse = property(parsed);\n        return Ok(parse);\n      } else {\n        return Err({\n          message: match.message ?? UNKNOWN_PARSE_ERROR,\n          shortMessage: match.shortMessage ?? UNKNOWN_PARSE_ERROR,\n        });\n      }\n    } catch (e) {\n      return Err(e as Error);\n    }\n  };\n}\n\nexport interface Span {\n  start: number;\n  end: number;\n}\n","const base = `\nBase {\n  Root = Value*\n\n  At = at\n  Bang = bang\n  Bar = bar\n  CloseAngle = closeAngle\n  CloseBrace = closeBrace\n  CloseParen = closeParen\n  CloseSquare = closeSquare\n  Comma = comma\n  Dollar = dollar\n  Dot = dot\n  DoubleQuote = doubleQuote\n  Equal = equal\n  OpenAngle = openAngle\n  OpenBrace = openBrace\n  OpenParen = openParen\n  OpenSquare = openSquare\n  Percent = percent\n  Semi = semi\n  Underscore = underscore\n\n  at = \"@\"\n  bang = \"!\"\n  bar = \"|\"\n  closeAngle = \">\"\n  closeBrace = \"}\"\n  closeParen = \")\"\n  closeSquare = \"]\"\n  comma = \",\"\n  dollar = \"$\"\n  dot = \".\"\n  doubleQuote = \"\\\\\"\"\n  equal = \"=\"\n  minus = \"-\"\n  newline = \"\\\\r\"? \"\\\\n\"\n  openAngle = \"<\"\n  openBrace = \"{\"\n  openParen = \"(\"\n  openSquare = \"[\"\n  percent = \"%\"\n  semi = \";\"\n  underscore = \"_\"\n\n  Value = identifier | number | boolean\n\n  boolean = true | false\n  True = true\n  False = false\n  true = \"true\"\n  false = \"false\"\n\n  Name = identifier\n  identifier = (letter|underscore) (alnum|underscore|dot|dollar)*\n\n  Number = number\n  number = hexNumber | decNumber | binNumber\n  binNumber = (\"%B\") (\"0\"|\"1\")+\n  hexNumber = (\"%X\") hexDigit+\n  decNumber = (\"%D\")? (wholeDec | realDec)\n  wholeDec = minus? digit+\n  realDec = minus? digit* \".\" digit+\n\n  String = DoubleQuote (~doubleQuote any)* doubleQuote\n  \n  spaces := (lineComment | comment | space)*\n  commentStart = \"/*\"\n  commentEnd = \"*/\"\n  comment = commentStart (~commentEnd any)* commentEnd\n  lineCommentStart = \"//\"\n  lineComment = lineCommentStart (~\"\\\\n\" any)* \"\\\\n\"\n\n  List<elem, sep> = NonemptyListOf<elem, sep> sep?\n  EmptyList<elem, sep> = EmptyList<elem, sep> sep?\n}`;\nexport default base;\n","const cmp = `\nCmp <: Base {\n  Root := line*\n  line = bar cell+ newline?\n  cell = cellvalue bar\n  cellvalue = (~(bar|newline) any)*\n}`;\nexport default cmp;\n","import ohm from \"ohm-js\";\nimport { grammars, makeParser, baseSemantics } from \"./base.js\";\n\nexport type Cell = string;\nexport type Line = Cell[];\nexport type Cmp = Line[];\n\nimport cmpGrammar from \"./grammars/cmp.ohm.js\";\nexport const grammar = ohm.grammar(cmpGrammar, grammars);\nexport const cmpSemantics = grammar.extendSemantics(baseSemantics);\n\ncmpSemantics.addAttribute<Cell>(\"cell\", {\n  cell(value, _) {\n    return value.sourceString;\n  },\n});\n\ncmpSemantics.addAttribute<Line>(\"line\", {\n  line(_a, cells, _b) {\n    return cells.children.map((c) => c.cell);\n  },\n});\n\ncmpSemantics.addAttribute<Cmp>(\"root\", {\n  Root(lines) {\n    return lines.children.map((c) => c.line);\n  },\n});\n\nexport const CMP = {\n  grammar: cmpGrammar,\n  semantics: cmpSemantics,\n  parser: grammar,\n  parse: makeParser<Cmp>(grammar, cmpSemantics),\n};\n","const tst = `\nTst <: Base {\n  Root := Tst\n  Tst = (TstStatement | TstRepeat | TstWhile)+\n\n  TstRepeat = Repeat Number? OpenBrace TstStatement+ CloseBrace\n  TstWhile = While Condition OpenBrace TstStatement+ CloseBrace\n  TstStatement = List<TstOperation, \",\"> (Semi | Bang)\n\n  TstOperation =\n    | TstFileOperation\n    | TstOutputListOperation\n    | TstEvalOperation\n    | TstSetOperation\n    | TstOutputOperation\n    | TstEchoOperation\n    | TstClearEchoOperation\n    | TstLoadROMOperation\n\n  TstLoadROMOperation = ROM32K Load FileName\n  TstFileOperation = FileOperation FileName?\n  TstOutputListOperation = \"output-list\" OutputFormat+\n  OutputFormat = Name Index? percent FormatStyle wholeDec dot wholeDec dot wholeDec\n  TstSetOperation = Set Name Index? Number\n  Index = OpenSquare wholeDec? CloseSquare\n  Condition = Value CompareOp Value\n  TstEvalOperation = Eval | Tick | Tock | TickTock | VmStep\n  TstOutputOperation = Output\n  TstEchoOperation = Echo String\n  TstClearEchoOperation = ClearEcho\n\n  FileName = Name\n  FileOperation = \"load\" | \"output-file\" | \"compare-to\"\n\n  Set = \"set\"\n  Eval = \"eval\"\n  Tick = \"tick\"\n  Tock = \"tock\"\n  TickTock = \"ticktock\"\n  VmStep = \"vmstep\"\n  Echo = \"echo\"\n  Repeat = \"repeat\"\n  ClearEcho = \"clear-echo\"\n  Output = \"output\"\n  OutputList = \"output-list\"\n  FormatStyle = \"B\"|\"D\"|\"S\"|\"X\"\n  ROM32K = \"ROM32K\"\n  Load = \"load\"\n  While = \"while\"\n\n  CompareOp = \"<>\" | \"<=\" | \">=\" | \"=\" | \"<\" | \">\"\n}`;\nexport default tst;\n","/** Reads tst files to apply and perform test runs. */\n\nimport ohm from \"ohm-js\";\nimport { baseSemantics, grammars, makeParser, Span } from \"./base.js\";\n\nexport interface TstEchoOperation {\n  op: \"echo\";\n  message: string;\n}\n\nexport interface TstClearEchoOperation {\n  op: \"clear-echo\";\n}\n\nexport interface TstSetOperation {\n  op: \"set\";\n  id: string;\n  index?: number;\n  value: number;\n}\n\nexport interface TstEvalOperation {\n  op: \"eval\" | \"tick\" | \"tock\" | \"ticktock\" | \"vmstep\";\n}\n\nexport interface TstOutputOperation {\n  op: \"output\";\n}\n\nexport interface TstOutputSpec {\n  id: string;\n  builtin: boolean;\n  address: number;\n  style: \"D\" | \"X\" | \"B\" | \"S\";\n  width: number;\n  lpad: number;\n  rpad: number;\n}\n\nexport interface TstOutputListOperation {\n  op: \"output-list\";\n  spec: TstOutputSpec[];\n}\n\nexport interface TstLoadROMOperation {\n  op: \"loadRom\";\n  file: string;\n}\n\nexport interface TstFileOperation {\n  op: \"load\" | \"output-file\" | \"compare-to\";\n  file?: string;\n}\n\nexport type TstOperation =\n  | TstFileOperation\n  | TstEvalOperation\n  | TstEchoOperation\n  | TstClearEchoOperation\n  | TstOutputOperation\n  | TstSetOperation\n  | TstOutputListOperation\n  | TstLoadROMOperation;\n\nexport interface TstLineStatement {\n  ops: TstOperation[];\n  break?: true;\n  span: Span;\n}\n\nexport interface TstRepeat {\n  statements: TstLineStatement[];\n  count: number;\n  span: Span;\n}\n\nexport interface TstWhileCondition {\n  op: \"<\" | \"<=\" | \"=\" | \">=\" | \">\" | \"<>\";\n  left: string | number;\n  right: string | number;\n}\n\nexport interface TstWhileStatement {\n  statements: TstLineStatement[];\n  condition: TstWhileCondition;\n  span: Span;\n}\n\nexport type TstStatement = TstLineStatement | TstRepeat | TstWhileStatement;\n\nexport interface Tst {\n  lines: TstStatement[];\n}\n\nimport tstGrammar from \"./grammars/tst.ohm.js\";\nexport const grammar = ohm.grammar(tstGrammar, grammars);\nexport const tstSemantics = grammar.extendSemantics(baseSemantics);\n\ntstSemantics.extendAttribute<number>(\"value\", {\n  Index(_a, idx, _b) {\n    return idx?.child(0)?.value ?? -1;\n  },\n});\n\ntstSemantics.extendAttribute<string>(\"name\", {\n  FileName({ name }) {\n    return name;\n  },\n});\n\ntstSemantics.addAttribute<number>(\"index\", {\n  Index(_open, dec, _close) {\n    return dec.child(0)?.value ?? 0;\n  },\n});\n\ntstSemantics.addAttribute<TstOutputSpec>(\"format\", {\n  OutputFormat(\n    { name: id },\n    index,\n    _a,\n    { sourceString: style },\n    { value: lpad },\n    _b,\n    { value: width },\n    _c,\n    { value: rpad }\n  ) {\n    return {\n      id,\n      builtin: index?.child(0) !== undefined,\n      address: index?.child(0)?.value ?? -1,\n      style: style as TstOutputSpec[\"style\"],\n      width,\n      lpad,\n      rpad,\n    };\n  },\n});\n\ntstSemantics.addAttribute<TstOperation>(\"operation\", {\n  TstEvalOperation(op) {\n    return { op: op.sourceString as TstEvalOperation[\"op\"] };\n  },\n  TstOutputOperation(_) {\n    return { op: \"output\" };\n  },\n  TstOutputListOperation(_, formats) {\n    return {\n      op: \"output-list\",\n      spec: formats.children.map((n) => n.format),\n    };\n  },\n  TstSetOperation(op, { name }, index, { value }) {\n    const setOp: TstSetOperation = {\n      op: \"set\",\n      id: name,\n      value,\n    };\n    const child = index.child(0)?.child(1)?.child(0);\n    if (child) {\n      setOp.index = child.value;\n    }\n    return setOp;\n  },\n  TstEchoOperation(op, str) {\n    return {\n      op: \"echo\",\n      message: str.String as string,\n    };\n  },\n  TstClearEchoOperation(op) {\n    return {\n      op: \"clear-echo\",\n    };\n  },\n  TstLoadROMOperation(_r, _l, { name }) {\n    return {\n      op: \"loadRom\",\n      file: name,\n    };\n  },\n  TstFileOperation(op, file) {\n    return {\n      op: op.sourceString as TstFileOperation[\"op\"],\n      file: file?.sourceString,\n    };\n  },\n});\n\ntstSemantics.addAttribute<TstWhileCondition>(\"condition\", {\n  Condition({ value: left }, { sourceString: op }, { value: right }) {\n    return {\n      left,\n      right,\n      op: op as \"<\" | \"<=\" | \"=\" | \">=\" | \">\" | \"<>\",\n    };\n  },\n});\n\ntstSemantics.addAttribute<TstStatement>(\"statement\", {\n  TstWhile(op, cond, _o, statements, _c) {\n    return {\n      statements: statements.children.map(({ statement }) => statement),\n      condition: cond.condition,\n      span: {\n        start: op.source.startIdx,\n        end: cond.source.endIdx,\n      },\n    };\n  },\n  TstRepeat(op, count, _o, statements, _c) {\n    return {\n      statements: statements.children.map(({ statement }) => statement),\n      count: count.child(0)?.value ?? -1,\n      span: {\n        start: op.source.startIdx,\n        end: count.source.endIdx,\n      },\n    };\n  },\n  TstStatement(list, end) {\n    const stmt: TstStatement = {\n      ops: list\n        .asIteration()\n        .children.map((node) => node.operation as TstOperation),\n      span: {\n        start: this.source.startIdx,\n        end: this.source.endIdx,\n      },\n    };\n    if (end.sourceString === \"!\") {\n      stmt.break = true;\n    }\n    return stmt;\n  },\n});\n\ntstSemantics.addAttribute<Tst>(\"tst\", {\n  Tst(lines) {\n    return {\n      lines: lines.children.map((n) => n.statement),\n    };\n  },\n});\n\ntstSemantics.addAttribute<Tst>(\"root\", {\n  Root({ tst }) {\n    return tst;\n  },\n});\n\nexport const TST = {\n  grammar: tstGrammar,\n  semantics: tstSemantics,\n  parser: grammar,\n  parse: makeParser<Tst>(grammar, tstSemantics),\n};\n","const vm = `\nVm <: Base {\n  Root := Vm\n\n  Vm = VmInstruction*\n\n  VmInstruction =\n    | StackInstruction\n    | OpInstruction\n    | FunctionInstruction\n    | CallInstruction\n    | ReturnInstruction\n    | GotoInstruction\n    | LabelInstruction\n  \n  StackInstruction = (Push | Pop) MemorySegment Number\n  OpInstruction = Add | Sub | Neg | Lt | Gt | Eq | And | Or | Not\n  FunctionInstruction = Function Name Number \n  CallInstruction =  Call Name Number\n  ReturnInstruction = Return\n  LabelInstruction = Label Name\n  GotoInstruction = (Goto | IfGoto) Name\n\n  MemorySegment = Argument | Local | Static | Constant | This | That | Pointer | Temp\n\n  Push = \"push\"\n  Pop = \"pop\"\n  Function = \"function\"\n  Call = \"call\"\n  Return = \"return\"\n  Goto = \"goto\"\n  IfGoto = \"if-goto\"\n  Label = \"label\"\n\n  Argument = \"argument\"\n  Local = \"local\"\n  Static = \"static\"\n  Constant = \"constant\"\n  This = \"this\"\n  That = \"that\"\n  Pointer = \"pointer\"\n  Temp = \"temp\"\n\n  Add = \"add\" \n  Sub = \"sub\" \n  Neg = \"neg\" \n  Eq = \"eq\"\n  Lt = \"lt\" \n  Gt = \"gt\" \n  And = \"and\" \n  Or = \"or\" \n  Not = \"not\"\n}`;\nexport default vm;\n","/** Reads tst files to apply and perform test runs. */\n\nimport ohm from \"ohm-js\";\nimport { baseSemantics, grammars, makeParser } from \"./base.js\";\n\nimport vmGrammar from \"./grammars/vm.ohm.js\";\nexport const grammar = ohm.grammar(vmGrammar, grammars);\nexport const vmSemantics = grammar.extendSemantics(baseSemantics);\n\nexport interface Vm {\n  instructions: VmInstruction[];\n}\n\nexport type VmInstruction =\n  | StackInstruction\n  | OpInstruction\n  | FunctionInstruction\n  | CallInstruction\n  | ReturnInstruction\n  | GotoInstruction\n  | LabelInstruction;\n\nexport interface StackInstruction {\n  op: \"push\" | \"pop\";\n  segment:\n    | \"argument\"\n    | \"local\"\n    | \"static\"\n    | \"constant\"\n    | \"this\"\n    | \"that\"\n    | \"pointer\"\n    | \"temp\";\n  offset: number;\n}\nexport interface OpInstruction {\n  op: \"add\" | \"sub\" | \"neg\" | \"lt\" | \"gt\" | \"eq\" | \"and\" | \"or\" | \"not\";\n}\nexport interface FunctionInstruction {\n  op: \"function\";\n  name: string;\n  nVars: number;\n}\nexport interface CallInstruction {\n  op: \"call\";\n  name: string;\n  nArgs: number;\n}\nexport interface ReturnInstruction {\n  op: \"return\";\n}\nexport interface LabelInstruction {\n  op: \"label\";\n  label: string;\n}\nexport interface GotoInstruction {\n  op: \"goto\" | \"if-goto\";\n  label: string;\n}\n\nvmSemantics.addAttribute<\n  | \"push\"\n  | \"pop\"\n  | \"function\"\n  | \"call\"\n  | \"return\"\n  | \"goto\"\n  | \"if-goto\"\n  | \"label\"\n  | \"add\"\n  | \"sub\"\n  | \"neg\"\n  | \"lt\"\n  | \"gt\"\n  | \"eq\"\n  | \"and\"\n  | \"or\"\n  | \"not\"\n>(\"op\", {\n  Push(_) {\n    return \"push\";\n  },\n  Pop(_) {\n    return \"pop\";\n  },\n  Function(_) {\n    return \"function\";\n  },\n  Call(_) {\n    return \"call\";\n  },\n  Return(_) {\n    return \"return\";\n  },\n  Goto(_) {\n    return \"goto\";\n  },\n  IfGoto(_) {\n    return \"if-goto\";\n  },\n  Label(_) {\n    return \"label\";\n  },\n  Add(_) {\n    return \"add\";\n  },\n  Sub(_) {\n    return \"sub\";\n  },\n  Neg(_) {\n    return \"neg\";\n  },\n  Eq(_) {\n    return \"eq\";\n  },\n  Lt(_) {\n    return \"lt\";\n  },\n  Gt(_) {\n    return \"gt\";\n  },\n  And(_) {\n    return \"and\";\n  },\n  Or(_) {\n    return \"or\";\n  },\n  Not(_) {\n    return \"not\";\n  },\n});\n\nvmSemantics.addAttribute<\n  | \"argument\"\n  | \"local\"\n  | \"static\"\n  | \"constant\"\n  | \"this\"\n  | \"that\"\n  | \"pointer\"\n  | \"temp\"\n>(\"segment\", {\n  Argument(_) {\n    return \"argument\";\n  },\n  Local(_) {\n    return \"local\";\n  },\n  Static(_) {\n    return \"static\";\n  },\n  Constant(_) {\n    return \"constant\";\n  },\n  This(_) {\n    return \"this\";\n  },\n  That(_) {\n    return \"that\";\n  },\n  Pointer(_) {\n    return \"pointer\";\n  },\n  Temp(_) {\n    return \"temp\";\n  },\n});\n\nvmSemantics.addAttribute<VmInstruction>(\"instruction\", {\n  StackInstruction({ op }, { segment }, { value }) {\n    return {\n      op: op as \"push\" | \"pop\",\n      segment,\n      offset: value,\n    };\n  },\n  OpInstruction({ op }) {\n    return {\n      op: op as\n        | \"add\"\n        | \"sub\"\n        | \"neg\"\n        | \"lt\"\n        | \"gt\"\n        | \"eq\"\n        | \"and\"\n        | \"or\"\n        | \"not\",\n    };\n  },\n  FunctionInstruction(_, { name }, { value: nArgs }) {\n    return { op: \"function\", name, nVars: nArgs };\n  },\n  CallInstruction(_, { name }, { value: nArgs }) {\n    return { op: \"call\", name, nArgs };\n  },\n  ReturnInstruction(_) {\n    return { op: \"return\" };\n  },\n  // LabelInstruction = Label Name\n  LabelInstruction(_, { name: label }) {\n    return { op: \"label\", label };\n  },\n  // GotoInstruction = (Goto | IfGoto) Name\n  GotoInstruction({ op }, { name: label }) {\n    return { op: op as \"goto\" | \"if-goto\", label };\n  },\n});\n\nvmSemantics.addAttribute<Vm>(\"vm\", {\n  Vm(lines) {\n    return {\n      instructions: lines.children.map((n) => n.instruction),\n    };\n  },\n});\n\nvmSemantics.addAttribute<Vm>(\"root\", {\n  Root({ vm }) {\n    return vm;\n  },\n});\n\nexport const VM = {\n  grammar: vmGrammar,\n  semantics: vmSemantics,\n  parser: grammar,\n  parse: makeParser<Vm>(grammar, vmSemantics),\n};\n","const asm = `\nASM <: Base {\n  Root := ASM\n  ASM = Instruction*\n  \n  Instruction = Label|AInstruction|CInstruction\n  \n  Label = OpenParen identifier closeParen\n  AInstruction = at (identifier | decNumber)\n  CInstruction = assign? op jmp?\n  \n  assign = (\n      \"AMD\"\n      | \"AM\"\n      | \"AD\"\n      | \"MD\"\n      | \"M\"\n      | \"D\"\n      | \"A\"\n      ) equal\n      \n  op =\n      | \"0\" | \"1\" | \"-1\"\n      | \"!D\" | \"!A\" | \"!M\"\n      | \"-D\" | \"-A\" | \"-M\"\n      | \"D+1\" | \"A+1\" | \"M+1\"\n      | \"D-1\" | \"A-1\" | \"M-1\"\n      | \"D+A\" | \"D+M\"\n      | \"D-A\" | \"D-M\"\n      | \"A-D\" | \"M-D\"\n      | \"D&A\" | \"D&M\"\n      | \"D|A\" | \"D|M\"\n      | \"D\" | \"A\" | \"M\"\n\n\n  jmp = semi (\"JGT\" | \"JEQ\" | \"JGE\" | \"JLT\" | \"JNE\" | \"JLE\" | \"JMP\")\n}`;\nexport default asm;\n","import { assertExists } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport ohm from \"ohm-js\";\nimport {\n  ASSIGN,\n  ASSIGN_ASM,\n  ASSIGN_OP,\n  COMMANDS,\n  COMMANDS_ASM,\n  COMMANDS_OP,\n  JUMP,\n  JUMP_ASM,\n  JUMP_OP,\n} from \"../cpu/alu.js\";\nimport { KEYBOARD_OFFSET, SCREEN_OFFSET } from \"../cpu/memory.js\";\nimport { makeC } from \"../util/asm.js\";\nimport { grammars, makeParser, baseSemantics } from \"./base.js\";\n\nimport asmGrammar from \"./grammars/asm.ohm.js\";\n\nexport const grammar = ohm.grammar(asmGrammar, grammars);\nexport const asmSemantics = grammar.extendSemantics(baseSemantics);\n\nexport interface Asm {\n  instructions: AsmInstruction[];\n}\n\nexport type AsmInstruction =\n  | AsmAInstruction\n  | AsmCInstruction\n  | AsmLabelInstruction;\n\nexport type AsmAInstruction = AsmALabelInstruction | AsmAValueInstruction;\nexport interface AsmALabelInstruction {\n  type: \"A\";\n  label: string;\n}\n\nexport interface AsmAValueInstruction {\n  type: \"A\";\n  value: number;\n}\n\nfunction isALabelInstruction(\n  inst: AsmAInstruction\n): inst is AsmALabelInstruction {\n  return (inst as AsmALabelInstruction).label !== undefined;\n}\n\nexport interface AsmCInstruction {\n  type: \"C\";\n  op: COMMANDS_OP;\n  isM: boolean;\n  store?: ASSIGN_OP;\n  jump?: JUMP_OP;\n}\n\nexport interface AsmLabelInstruction {\n  type: \"L\";\n  label: string;\n}\n\nasmSemantics.addAttribute<Asm>(\"root\", {\n  Root(_) {\n    return this.asm;\n  },\n});\n\nasmSemantics.addAttribute<Asm>(\"asm\", {\n  Root(asm) {\n    return {\n      instructions: asm\n        .child(0)\n        .children.map(({ instruction }) => instruction as AsmInstruction),\n    };\n  },\n});\n\nasmSemantics.addAttribute<AsmInstruction>(\"instruction\", {\n  AInstruction(_at, val): AsmAInstruction {\n    try {\n      return {\n        type: \"A\",\n        label: val.name,\n      };\n    } catch (e) {\n      // Pass\n    }\n\n    try {\n      return {\n        type: \"A\",\n        value: val.value,\n      };\n    } catch (e) {\n      // pass\n    }\n\n    throw new Error(`AsmAInstruction must have either a name or a value`);\n  },\n  CInstruction(assignN, opN, jmpN): AsmCInstruction {\n    const assign = assignN.child(0)?.child(0)?.sourceString as ASSIGN_ASM;\n    const op = opN.sourceString.replace(\"M\", \"A\") as COMMANDS_ASM;\n    const jmp = jmpN.child(0)?.child(1)?.sourceString as JUMP_ASM;\n    const isM =\n      assignN.sourceString.includes(\"M\") || opN.sourceString.includes(\"M\");\n    const inst: AsmCInstruction = {\n      type: \"C\",\n      op: COMMANDS.asm[op],\n      isM,\n    };\n    if (jmp) inst.jump = JUMP.asm[jmp];\n    if (assign) inst.store = ASSIGN.asm[assign];\n    return inst;\n  },\n  Label(_o, { name }, _c): AsmLabelInstruction {\n    return {\n      type: \"L\",\n      label: name,\n    };\n  },\n});\n\nexport type Pointer =\n  | \"R0\"\n  | \"R1\"\n  | \"R2\"\n  | \"R3\"\n  | \"R4\"\n  | \"R5\"\n  | \"R6\"\n  | \"R7\"\n  | \"R8\"\n  | \"R9\"\n  | \"R10\"\n  | \"R11\"\n  | \"R12\"\n  | \"R13\"\n  | \"R14\"\n  | \"R15\"\n  | \"SP\"\n  | \"LCL\"\n  | \"ARG\"\n  | \"THIS\"\n  | \"THAT\"\n  | \"SCREEN\"\n  | \"KBD\";\n\nexport function fillLabel(asm: Asm) {\n  let nextLabel = 16;\n  const symbols = new Map<Pointer | string, number>([\n    [\"R0\", 0],\n    [\"R1\", 1],\n    [\"R2\", 2],\n    [\"R3\", 3],\n    [\"R4\", 4],\n    [\"R5\", 5],\n    [\"R6\", 6],\n    [\"R7\", 7],\n    [\"R8\", 8],\n    [\"R9\", 9],\n    [\"R10\", 10],\n    [\"R11\", 11],\n    [\"R12\", 12],\n    [\"R13\", 13],\n    [\"R14\", 14],\n    [\"R15\", 15],\n    [\"SP\", 0],\n    [\"LCL\", 1],\n    [\"ARG\", 2],\n    [\"THIS\", 3],\n    [\"THAT\", 4],\n    [\"SCREEN\", SCREEN_OFFSET],\n    [\"KBD\", KEYBOARD_OFFSET],\n  ]);\n\n  function getLabelValue(label: string) {\n    if (!symbols.has(label)) {\n      symbols.set(label, nextLabel);\n      nextLabel += 1;\n    }\n    return assertExists(symbols.get(label), `Label not in symbols: ${label}`);\n  }\n\n  function transmuteAInstruction(instruction: AsmALabelInstruction) {\n    const value = getLabelValue(instruction.label);\n    (instruction as unknown as AsmAValueInstruction).value = value;\n    delete (instruction as unknown as { label: undefined }).label;\n  }\n\n  const unfilled: AsmALabelInstruction[] = [];\n  let line = 0;\n  for (const instruction of asm.instructions) {\n    if (instruction.type === \"L\") {\n      if (symbols.has(instruction.label)) {\n        throw new Error(`ASM Duplicate label ${instruction.label}`);\n      } else {\n        symbols.set(instruction.label, line);\n      }\n      continue;\n    }\n\n    line += 1;\n\n    if (instruction.type === \"A\") {\n      if (isALabelInstruction(instruction)) {\n        unfilled.push(instruction);\n      }\n    }\n  }\n\n  unfilled.forEach(transmuteAInstruction);\n}\n\nfunction writeCInst(inst: AsmCInstruction): string {\n  return (\n    (inst.store ? `${ASSIGN.op[inst.store]}=` : \"\") +\n    COMMANDS.op[inst.op] +\n    (inst.jump ? `;${JUMP.op[inst.jump]}` : \"\")\n  );\n}\n\nexport const AsmToString = (inst: AsmInstruction | string): string => {\n  if (typeof inst === \"string\") return inst;\n  switch (inst.type) {\n    case \"A\":\n      return isALabelInstruction(inst) ? `@${inst.label}` : `@${inst.value}`;\n    case \"L\":\n      return `(${inst.label})`;\n    case \"C\":\n      return writeCInst(inst);\n  }\n};\n\nexport const asmToInt = (inst: AsmInstruction): number | undefined => {\n  if (inst.type === \"A\") {\n    if (isALabelInstruction(inst)) {\n      throw new Error(`ASM Emitting unfilled A instruction`);\n    }\n    return inst.value;\n  }\n  if (inst.type === \"C\") {\n    return makeC(inst.isM, inst.op, inst.store, inst.jump);\n  }\n  return undefined;\n};\n\nexport function emit(asm: Asm): number[] {\n  return asm.instructions\n    .map(asmToInt)\n    .filter((op): op is number => op !== undefined);\n}\n\nconst A = (source: string | number): AsmAInstruction =>\n  typeof source === \"string\"\n    ? { type: \"A\", label: source }\n    : { type: \"A\", value: source };\nconst C = (\n  assign: ASSIGN_ASM,\n  op: COMMANDS_ASM,\n  jmp?: JUMP_ASM\n): AsmCInstruction => {\n  const isM = assign.includes(\"M\") || op.includes(\"M\");\n  const inst: AsmCInstruction = {\n    type: \"C\",\n    op: COMMANDS.asm[op],\n    isM,\n  };\n  if (jmp) inst.jump = JUMP.asm[jmp];\n  if (assign) inst.store = ASSIGN.asm[assign];\n  return inst;\n};\nconst AC = (\n  source: string | number,\n  assign: ASSIGN_ASM,\n  op: COMMANDS_ASM,\n  jmp?: JUMP_ASM\n) => [A(source), C(assign, op, jmp)];\nconst L = (label: string): AsmLabelInstruction => ({ type: \"L\", label });\n\nexport const ASM = {\n  grammar: asmGrammar,\n  semantics: asmSemantics,\n  parser: grammar,\n  parse: makeParser<Asm>(grammar, asmSemantics),\n  passes: {\n    fillLabel,\n    emit,\n  },\n  A,\n  C,\n  AC,\n  L,\n};\n","import { unwrap } from \"@davidsouther/jiffies/lib/esm/result.js\";\nimport { ASM } from \"./languages/asm.js\";\nimport { int2, parseTwosInt } from \"./util/twos.js\";\n\nexport async function loadAsm(source: string): Promise<number[]> {\n  const asm = unwrap(ASM.parse(source));\n  ASM.passes.fillLabel(asm);\n  return ASM.passes.emit(asm);\n}\n\nexport async function loadHack(source: string): Promise<number[]> {\n  return source\n    .split(\"\\n\")\n    .filter((line) => line.trim() !== \"\")\n    .map(int2);\n}\n\nexport async function loadBlob(bytes: string): Promise<number[]> {\n  return bytes\n    .split(\"\\n\")\n    .filter((line) => line.trim() !== \"\")\n    .map(parseTwosInt);\n}\n","import { assert } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { bin, dec, hex } from \"./util/twos.js\";\nimport { Test } from \"./test/tst.js\";\n\nexport class Output {\n  private readonly fmt: \"B\" | \"X\" | \"D\" | \"S\";\n  private readonly lPad: number;\n  private readonly rPad: number;\n  private readonly len: number;\n  private readonly index: number;\n  private readonly builtin: boolean;\n\n  // new Output(inst.id, inst.style, inst.width, inst.lpad, inst.rpad)\n  constructor(\n    private variable: string,\n    format = \"%B1.1.1\",\n    len?: number,\n    lPad?: number,\n    rPad?: number,\n    builtin?: boolean,\n    index?: number\n  ) {\n    if (\n      format.startsWith(\"%\") &&\n      len === undefined &&\n      lPad === undefined &&\n      rPad === undefined\n    ) {\n      const { fmt, lPad, rPad, len } = format.match(\n        /^%(?<fmt>[BDXS])(?<lPad>\\d+)\\.(?<len>\\d+)\\.(?<rPad>\\d+)$/\n      )?.groups as {\n        fmt: \"B\" | \"X\" | \"D\" | \"S\";\n        lPad: string;\n        rPad: string;\n        len: string;\n      };\n      this.fmt = fmt;\n      this.lPad = parseInt(lPad);\n      this.rPad = parseInt(rPad);\n      this.len = parseInt(len);\n      this.builtin = false;\n      this.index = -1;\n    } else {\n      assert([\"B\", \"X\", \"D\", \"S\"].includes(format[0]));\n      this.fmt = format[0] as \"B\" | \"X\" | \"D\" | \"S\";\n      this.len = len ?? 3;\n      this.lPad = lPad ?? 1;\n      this.rPad = rPad ?? 1;\n      this.builtin = builtin ?? false;\n      this.index = index ?? -1;\n    }\n  }\n\n  header(test: Test) {\n    let variable = `${this.variable}`;\n    if (this.builtin) {\n      const index = this.index >= 0 ? this.index : \"\";\n      variable = `${variable}[${index}]`;\n    }\n    if (variable.length > this.len + this.lPad + this.rPad) {\n      return variable.substring(0, this.len + this.lPad + this.rPad);\n    }\n    return this.padCenter(variable);\n  }\n\n  print(test: Test) {\n    const val = test.getVar(this.variable, this.index);\n    if (this.fmt === \"S\") {\n      return this.padLeft(val as string);\n    }\n\n    const fmt = { B: bin, D: dec, X: hex }[this.fmt];\n    const value = fmt(val as number);\n    if (this.fmt === \"D\") {\n      return this.padRight(value);\n    } else {\n      return this.padCenter(value.slice(value.length - this.len));\n    }\n  }\n\n  private padCenter(value: string) {\n    const space = this.lPad + this.len + this.rPad;\n    const leftSpace = Math.floor((space - value.length) / 2);\n    const rightSpace = space - leftSpace - value.length;\n    const padLeft = leftSpace + value.length;\n    const padRight = padLeft + rightSpace;\n    value = value.padStart(padLeft);\n    value = value.padEnd(padRight);\n    return value;\n  }\n\n  private padLeft(value: string) {\n    value = value.substring(0, this.len);\n    const padRight = this.rPad + this.len;\n    const padLeft = this.lPad + padRight;\n    value = value.padEnd(padRight);\n    value = value.padStart(padLeft);\n    return value;\n  }\n\n  private padRight(value: string) {\n    value = value.substring(0, this.len);\n    const padLeft = this.lPad + this.len;\n    const padRight = this.rPad + padLeft;\n    value = value.padStart(padLeft);\n    value = value.padEnd(padRight);\n    return value;\n  }\n}\n","import { Span } from \"../languages/base.js\";\nimport { TstOutputSpec } from \"../languages/tst.js\";\nimport { Output } from \"../output.js\";\nimport { Test } from \"./tst.js\";\n\nexport interface TestInstruction {\n  span?: Span;\n  do(test: Test): void;\n  steps(test: Test): IterableIterator<TestInstruction>;\n}\n\nexport class TestSetInstruction implements TestInstruction {\n  constructor(\n    private variable: string,\n    private value: number,\n    private index?: number | undefined\n  ) {}\n\n  do(test: Test) {\n    test.setVar(this.variable, this.value, this.index);\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestOutputInstruction implements TestInstruction {\n  do(test: Test) {\n    test.output();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestOutputListInstruction implements TestInstruction {\n  private outputs: Output[] = [];\n\n  constructor(specs: TstOutputSpec[] = []) {\n    for (const spec of specs) {\n      this.addOutput(spec);\n    }\n  }\n\n  addOutput(inst: TstOutputSpec) {\n    this.outputs.push(\n      new Output(\n        inst.id,\n        inst.style,\n        inst.width,\n        inst.lpad,\n        inst.rpad,\n        inst.builtin,\n        inst.address\n      )\n    );\n  }\n\n  do(test: Test) {\n    test.outputList(this.outputs);\n    test.header();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestCompoundInstruction implements TestInstruction {\n  protected readonly instructions: TestInstruction[] = [];\n  span?: Span;\n\n  addInstruction(instruction: TestInstruction) {\n    this.instructions.push(instruction);\n  }\n\n  do(test: Test<TestInstruction>): void {\n    for (const instruction of this.instructions) {\n      instruction.do(test);\n    }\n  }\n\n  *steps(_test: Test): Generator<TestInstruction> {\n    yield this;\n  }\n}\n\nexport class TestRepeatInstruction extends TestCompoundInstruction {\n  constructor(public readonly repeat: number) {\n    super();\n  }\n\n  override do() {\n    return undefined;\n  }\n\n  private *innerSteps(test: Test): Generator<TestInstruction> {\n    for (const instruction of this.instructions) {\n      yield* instruction.steps(test) as Generator<TestInstruction>;\n    }\n  }\n\n  override *steps(test: Test): Generator<TestInstruction> {\n    if (this.repeat === -1) {\n      yield this;\n      while (true) {\n        yield* this.innerSteps(test);\n      }\n    } else {\n      for (let i = 0; i < this.repeat; i++) {\n        yield this;\n        yield* this.innerSteps(test);\n      }\n    }\n  }\n}\n\nexport class Condition {\n  constructor(\n    public readonly x: string | number,\n    public readonly y: string | number,\n    public readonly op: \"<\" | \"<=\" | \"=\" | \">=\" | \">\" | \"<>\"\n  ) {}\n\n  check(test: Test): boolean {\n    const x = test.hasVar(this.x) ? test.getVar(this.x) : this.x;\n    const y = test.hasVar(this.y) ? test.getVar(this.y) : this.y;\n\n    if (typeof x === \"string\" || typeof y === \"string\") {\n      switch (this.op) {\n        case \"=\":\n          return `${x}` === `${y}`;\n        case \"<>\":\n          return `${x}` !== `${y}`;\n      }\n    } else {\n      switch (this.op) {\n        case \"<\":\n          return x < y;\n        case \"<=\":\n          return x <= y;\n        case \">\":\n          return x > y;\n        case \">=\":\n          return x >= y;\n        case \"=\":\n          return x === y;\n        case \"<>\":\n          return x !== y;\n      }\n    }\n    return false;\n  }\n}\n\nexport class TestWhileInstruction extends TestCompoundInstruction {\n  constructor(public readonly condition: Condition) {\n    super();\n  }\n\n  override *steps(test: Test): Generator<TestInstruction> {\n    while (this.condition.check(test)) {\n      yield this;\n      for (const instruction of this.instructions) {\n        yield* instruction.steps(test) as Generator<TestInstruction>;\n      }\n    }\n  }\n}\n\nexport class TestEchoInstruction implements TestInstruction {\n  constructor(public readonly content: string) {}\n  do(test: Test) {\n    test.echo(this.content);\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestClearEchoInstruction implements TestInstruction {\n  do(test: Test) {\n    test.clearEcho();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestLoadROMInstruction implements TestInstruction {\n  constructor(readonly file: string) {}\n  async do(test: Test) {\n    test.fs.pushd(\"/samples\");\n    await test.load(this.file);\n    test.fs.popd();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestLoadInstruction implements TestInstruction {\n  constructor(readonly file?: string) {}\n\n  async do(test: Test) {\n    await test.load(this.file);\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestBreakpointInstruction implements TestInstruction {\n  constructor(readonly variable: string, readonly value: number) {}\n\n  do(test: Test) {\n    test.addBreakpoint(this.variable, this.value);\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestClearBreakpointsInstruction implements TestInstruction {\n  do(test: Test) {\n    test.clearBreakpoints();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n","import { checkExhaustive } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport {\n  Tst,\n  TstLineStatement,\n  TstOperation,\n  TstStatement,\n  TstWhileStatement,\n} from \"../languages/tst.js\";\nimport {\n  TestEvalInstruction,\n  TestTickInstruction,\n  TestTockInstruction,\n} from \"./chiptst.js\";\nimport {\n  Condition,\n  TestClearEchoInstruction,\n  TestCompoundInstruction,\n  TestEchoInstruction,\n  TestLoadROMInstruction,\n  TestOutputInstruction,\n  TestOutputListInstruction,\n  TestRepeatInstruction,\n  TestSetInstruction,\n  TestWhileInstruction,\n} from \"./instruction.js\";\nimport { Test } from \"./tst.js\";\nimport { TestVMStepInstruction } from \"./vmtst.js\";\nimport { TestTickTockInstruction } from \"./cputst.js\";\n\nfunction isTstLineStatment(line: TstStatement): line is TstLineStatement {\n  return (line as TstLineStatement).ops !== undefined;\n}\n\nfunction isTstWhileStatement(line: TstStatement): line is TstWhileStatement {\n  return (line as TstWhileStatement).condition !== undefined;\n}\n\nfunction makeLineStatement(line: TstLineStatement) {\n  const statement = new TestCompoundInstruction();\n  statement.span = line.span;\n  for (const op of line.ops) {\n    const inst = makeInstruction(op);\n    if (inst !== undefined) statement.addInstruction(inst);\n  }\n  return statement;\n}\n\nfunction makeInstruction(inst: TstOperation) {\n  const { op } = inst;\n  switch (op) {\n    case \"tick\":\n      return new TestTickInstruction();\n    case \"tock\":\n      return new TestTockInstruction();\n    case \"ticktock\":\n      return new TestTickTockInstruction();\n    case \"eval\":\n      return new TestEvalInstruction();\n    case \"vmstep\":\n      return new TestVMStepInstruction();\n    case \"output\":\n      return new TestOutputInstruction();\n    case \"set\":\n      return new TestSetInstruction(inst.id, inst.value, inst.index);\n    case \"output-list\":\n      return new TestOutputListInstruction(inst.spec);\n    case \"echo\":\n      return new TestEchoInstruction(inst.message);\n    case \"clear-echo\":\n      return new TestClearEchoInstruction();\n    case \"loadRom\":\n      return new TestLoadROMInstruction(inst.file);\n    case \"load\":\n    case \"output-file\":\n    case \"compare-to\":\n      return undefined;\n    default:\n      checkExhaustive(op, `Unknown tst operation ${op}`);\n  }\n}\n\nexport function fill<T extends Test>(test: T, tst: Tst): T {\n  for (const line of tst.lines) {\n    if (isTstLineStatment(line)) {\n      test.addInstruction(makeLineStatement(line));\n    } else {\n      const repeat = isTstWhileStatement(line)\n        ? new TestWhileInstruction(\n            new Condition(\n              line.condition.left,\n              line.condition.right,\n              line.condition.op\n            )\n          )\n        : new TestRepeatInstruction(line.count);\n      repeat.span = line.span;\n      test.addInstruction(repeat);\n      for (const statement of line.statements) {\n        repeat.addInstruction(makeLineStatement(statement));\n      }\n    }\n  }\n\n  test.reset();\n\n  return test;\n}\n","import { Bus, Chip, HIGH, Low, LOW } from \"../chip/chip.js\";\nimport { Clock } from \"../chip/clock.js\";\nimport { Tst } from \"../languages/tst.js\";\nimport { fill } from \"./builder.js\";\nimport { TestInstruction } from \"./instruction.js\";\nimport { Test } from \"./tst.js\";\n\nexport class ChipTest extends Test<ChipTestInstruction> {\n  private chip: Chip = new Low();\n  get chipId(): number {\n    return this.chip.id;\n  }\n\n  private clock = Clock.get();\n\n  static from(tst: Tst): ChipTest {\n    const test = new ChipTest();\n    return fill(test, tst);\n  }\n\n  with(chip: Chip): this {\n    this.chip = chip;\n    return this;\n  }\n\n  hasVar(variable: string | number): boolean {\n    if (variable === \"time\") {\n      return true;\n    }\n    variable = `${variable}`;\n    // Look up built-in chip state variables\n    return this.chip.hasIn(variable) || this.chip.hasOut(variable);\n  }\n\n  getVar(variable: string | number, offset?: number): number | string {\n    variable = `${variable}`;\n    if (variable === \"time\") {\n      return this.clock.toString();\n    }\n    const pin = this.chip.get(variable, offset);\n    if (!pin) return 0;\n    return pin instanceof Bus ? pin.busVoltage : pin.voltage();\n  }\n\n  setVar(variable: string, value: number, offset?: number): void {\n    // Look up built-in chip state variables\n    const pinOrBus = this.chip.get(variable, offset);\n    if (pinOrBus instanceof Bus) {\n      pinOrBus.busVoltage = value;\n    } else {\n      pinOrBus?.pull(value === 0 ? LOW : HIGH);\n    }\n  }\n\n  eval(): void {\n    this.chip.eval();\n  }\n\n  tick(): void {\n    this.chip.eval();\n    this.clock.tick();\n  }\n\n  tock(): void {\n    this.chip.eval();\n    this.clock.tock();\n  }\n\n  override async load(filename: string) {\n    await this.chip.load(this.fs, filename);\n  }\n\n  override async run() {\n    this.clock.reset();\n    await super.run();\n  }\n}\n\nexport interface ChipTestInstruction extends TestInstruction {\n  _chipTestInstruction_: true;\n  do(test: ChipTest): void | Promise<void>;\n}\n\nexport class TestEvalInstruction implements ChipTestInstruction {\n  readonly _chipTestInstruction_ = true;\n  do(test: ChipTest) {\n    test.eval();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestTickInstruction implements ChipTestInstruction {\n  readonly _chipTestInstruction_ = true;\n  do(test: ChipTest) {\n    test.tick();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n\nexport class TestTockInstruction implements ChipTestInstruction {\n  readonly _chipTestInstruction_ = true;\n  do(test: ChipTest) {\n    test.tock();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n","import { ROM } from \"../cpu/memory.js\";\nimport { CPU } from \"../cpu/cpu.js\";\nimport { Test } from \"./tst.js\";\nimport { Tst } from \"../languages/tst.js\";\nimport { TestInstruction } from \"./instruction.js\";\nimport { fill } from \"./builder.js\";\n\nexport class CPUTest extends Test<CPUTestInstruction> {\n  readonly cpu: CPU;\n  private ticks = 0;\n\n  static from(tst: Tst): CPUTest {\n    const test = new CPUTest();\n    return fill(test, tst);\n  }\n\n  constructor(rom: ROM = new ROM(new Int16Array())) {\n    super();\n    this.cpu = new CPU({ ROM: rom });\n    this.reset();\n  }\n\n  override reset(): this {\n    this.cpu.reset();\n    this.ticks = 0;\n    return this;\n  }\n\n  hasVar(variable: string | number): boolean {\n    if (typeof variable === \"number\") {\n      return false;\n    }\n    // A: Current value of the address register (unsigned 15-bit);\n    // D: Current value of the data register (16-bit);\n    // PC: Current value of the Program Counter (unsigned 15-bit);\n    // RAM[i]: Current value of RAM location i (16-bit);\n    // time: Number of time units (also called clock cycles, or ticktocks) that elapsed since the simulation started (a read-only system variable).\n    if (\n      variable === \"A\" ||\n      variable === \"D\" ||\n      variable === \"PC\" ||\n      variable === \"time\" ||\n      variable.startsWith(\"RAM\")\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  getVar(variable: string | number): number {\n    switch (variable) {\n      case \"A\":\n        return this.cpu.A;\n      case \"D\":\n        return this.cpu.D;\n      case \"PC\":\n        return this.cpu.PC;\n      case \"time\":\n        return this.ticks;\n    }\n    if (typeof variable === \"number\") return 0;\n    if (variable.startsWith(\"RAM\")) {\n      const num = Number(variable.substring(4, variable.length - 1));\n      return this.cpu.RAM.get(num);\n    }\n    return 0;\n  }\n\n  setVar(variable: string, value: number, index?: number): void {\n    // A: Current value of the address register (unsigned 15-bit);\n    // D: Current value of the data register (16-bit);\n    // PC: Current value of the Program Counter (unsigned 15-bit);\n    // RAM[i]: Current value of RAM location i (16-bit);\n    switch (variable) {\n      case \"A\":\n        this.cpu.setA(value);\n        break;\n      case \"D\":\n        this.cpu.setD(value);\n        break;\n      case \"PC\":\n        this.cpu.setPC(value);\n        break;\n      case \"RAM\":\n        this.cpu.RAM.set(index ?? 0, value);\n        break;\n    }\n    return;\n  }\n\n  ticktock(): void {\n    this.ticks += 1;\n    this.cpu.tick();\n  }\n\n  override async load(filename: string): Promise<void> {\n    await this.cpu.ROM.load(this.fs, filename);\n  }\n}\n\nexport interface CPUTestInstruction extends TestInstruction {\n  _cpuTestInstruction_: true;\n  do(test: CPUTest): void | Promise<void>;\n}\n\nexport class TestTickTockInstruction implements CPUTestInstruction {\n  readonly _cpuTestInstruction_ = true;\n  do(test: CPUTest) {\n    test.ticktock();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n","import { assertExists } from \"@davidsouther/jiffies/lib/esm/assert.js\";\nimport { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport { Output } from \"../output.js\";\nimport { TestInstruction } from \"./instruction.js\";\n\nexport abstract class Test<IS extends TestInstruction = TestInstruction> {\n  protected readonly instructions: (IS | TestInstruction)[] = [];\n  protected _outputList: Output[] = [];\n  protected _log = \"\";\n  fs: FileSystem = new FileSystem();\n\n  setFileSystem(fs: FileSystem): this {\n    this.fs = fs;\n    return this;\n  }\n\n  echo(_content: string) {\n    return undefined;\n  }\n  clearEcho() {\n    return undefined;\n  }\n\n  async load(_filename?: string): Promise<void> {\n    return undefined;\n  }\n  async compareTo(_filename: string): Promise<void> {\n    return undefined;\n  }\n  outputFile(_filename: string): void {\n    return undefined;\n  }\n  outputList(outputs: Output[]): void {\n    this._outputList = outputs;\n  }\n\n  addInstruction(instruction: IS | TestInstruction): void {\n    this.instructions.push(instruction);\n  }\n\n  reset(): this {\n    this._steps = (function* (test) {\n      for (const instruction of test.instructions) {\n        yield* instruction.steps(test);\n      }\n    })(this);\n    this._step = this._steps.next();\n    this._log = \"\";\n    return this;\n  }\n\n  private _steps!: IterableIterator<IS | TestInstruction>;\n  private _step!: IteratorResult<IS | TestInstruction, IS | TestInstruction>;\n\n  get steps(): Iterator<IS | TestInstruction> {\n    if (this._steps === undefined) {\n      this.reset();\n      this._steps = assertExists(this._steps, \"Reset did not initialize steps\");\n      this._step = assertExists(this._step, \"Reset did not find first step\");\n    }\n    return this._steps;\n  }\n\n  get currentStep(): IS | TestInstruction | undefined {\n    return this._step?.value;\n  }\n\n  get done(): boolean {\n    return this._step?.done ?? false;\n  }\n\n  step() {\n    if (!this._step.done) {\n      this._step.value.do(this);\n      this._step = this.steps.next();\n      return false;\n    }\n    return true;\n  }\n\n  async run() {\n    this.reset();\n    while (!(await this.step()));\n  }\n\n  protected readonly breakpoints: Map<string, number> = new Map();\n  addBreakpoint(variable: string, value: number) {\n    this.breakpoints.set(variable, value);\n  }\n  clearBreakpoints() {\n    this.breakpoints.clear();\n  }\n\n  output() {\n    const values = this._outputList.map((output) => output.print(this));\n    this._log += `|${values.join(\"|\")}|\\n`;\n  }\n\n  header() {\n    const values = this._outputList.map((output) => output.header(this));\n    this._log += `|${values.join(\"|\")}|\\n`;\n  }\n\n  log() {\n    return this._log;\n  }\n\n  abstract hasVar(variable: string | number): boolean;\n  abstract getVar(variable: string | number, offset?: number): number | string;\n  abstract setVar(variable: string, value: number, offset?: number): void;\n}\n","import { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\nimport { unwrap } from \"@davidsouther/jiffies/lib/esm/result.js\";\nimport { RAM } from \"../cpu/memory.js\";\nimport { Tst } from \"../languages/tst.js\";\nimport { VM } from \"../languages/vm.js\";\nimport { Segment, Vm } from \"../vm/vm.js\";\nimport { fill } from \"./builder.js\";\nimport { TestInstruction } from \"./instruction.js\";\nimport { Test } from \"./tst.js\";\n\nexport class VMTest extends Test<VMTestInstruction> {\n  vm: Vm = new Vm();\n\n  static from(tst: Tst): VMTest {\n    const test = new VMTest();\n    return fill(test, tst);\n  }\n\n  using(fs: FileSystem): this {\n    this.fs = fs;\n    return this;\n  }\n\n  with(vm: Vm) {\n    this.vm = vm;\n    return this;\n  }\n\n  hasVar(variable: string | number, index?: number): boolean {\n    if (typeof variable !== \"string\") {\n      index = variable;\n      variable = \"RAM\";\n    }\n    if (\n      variable === \"RAM\" &&\n      index !== undefined &&\n      index > 0 &&\n      index < RAM.SIZE\n    ) {\n      return true;\n    }\n    return [\n      \"argument\",\n      \"local\",\n      \"static\",\n      \"constant\",\n      \"this\",\n      \"that\",\n      \"pointer\",\n      \"temp\",\n    ].includes(variable.toLowerCase());\n  }\n\n  getVar(variable: string | number, index?: number): number {\n    if (typeof variable !== \"string\") {\n      index = variable;\n      variable = \"RAM\";\n    }\n    if (\n      variable === \"RAM\" &&\n      index !== undefined &&\n      index > 0 &&\n      index < RAM.SIZE\n    ) {\n      return this.vm.RAM.get(index);\n    }\n    return this.vm.memory.getSegment(variable as Segment, index ?? 0);\n  }\n\n  setVar(variable: string, value: number, index?: number): void {\n    if (typeof variable !== \"string\") {\n      index = variable;\n      variable = \"RAM\";\n    }\n    if (\n      variable === \"RAM\" &&\n      index !== undefined &&\n      index > 0 &&\n      index < RAM.SIZE\n    ) {\n      this.vm.RAM.set(index, value);\n    }\n    if (index) {\n      this.vm.memory.setSegment(variable as Segment, index, value);\n    } else {\n      switch (variable.toLowerCase()) {\n        case \"sp\":\n          this.vm.memory.SP = value;\n          break;\n        case \"arg\":\n        case \"argument\":\n          this.vm.memory.ARG = value;\n          break;\n        case \"lcl\":\n        case \"local\":\n          this.vm.memory.LCL = value;\n          break;\n        case \"this\":\n          this.vm.memory.THIS = value;\n          break;\n        case \"that\":\n          this.vm.memory.THAT = value;\n          break;\n      }\n    }\n  }\n\n  vmstep(): void {\n    this.vm.step();\n  }\n\n  override async load(filename?: string) {\n    if (filename) {\n      const file = await this.fs.readFile(filename);\n      const { instructions } = unwrap(VM.parse(file));\n      unwrap(this.vm.load(instructions));\n    } else {\n      for (const file of await this.fs.scandir(\".\")) {\n        if (file.isFile() && file.name.endsWith(\".vm\")) {\n          await this.load(file.name);\n        }\n      }\n    }\n    unwrap(this.vm.bootstrap());\n  }\n}\n\nexport interface VMTestInstruction extends TestInstruction {\n  _vmTestInstruction_: true;\n  do(test: VMTest): void | Promise<void>;\n}\n\nexport class TestVMStepInstruction implements VMTestInstruction {\n  readonly _vmTestInstruction_ = true;\n  do(test: VMTest) {\n    test.vmstep();\n  }\n\n  *steps() {\n    yield this;\n  }\n}\n","import {\n  ASSIGN,\n  ASSIGN_ASM,\n  ASSIGN_OP,\n  COMMANDS,\n  COMMANDS_ASM,\n  COMMANDS_OP,\n  JUMP,\n  JUMP_ASM,\n  JUMP_OP,\n} from \"../cpu/alu.js\";\n\nexport type CommandOps = keyof typeof COMMANDS.op;\nexport type JumpOps = keyof typeof JUMP.op;\nexport type StoreOps = keyof typeof ASSIGN.op;\n\nexport function asm(op: number): string {\n  if (op & 0x8000) {\n    return cInstruction(op);\n  }\n  return aInstruction(op);\n}\n\nfunction cInstruction(op: number): string {\n  op = op & 0xffff; // Clear high order bits\n  const mop = (op & 0x1000) >> 12;\n  const cop: CommandOps = ((op & 0b0000111111000000) >> 6) as CommandOps;\n  const sop: StoreOps = ((op & 0b0000000000111000) >> 3) as StoreOps;\n  const jop: JumpOps = (op & 0b0000000000000111) as JumpOps;\n\n  if (COMMANDS.op[cop] === undefined) {\n    // Invalid commend\n    return \"#ERR\";\n  }\n\n  let command = COMMANDS.op[cop];\n  if (mop) {\n    command = command.replace(/A/g, \"M\") as COMMANDS_ASM;\n  }\n\n  const store = ASSIGN.op[sop];\n  const jump = JUMP.op[jop];\n\n  let instruction: string = command;\n  if (store) {\n    instruction = `${store}=${instruction}`;\n  }\n  if (jump) {\n    instruction = `${instruction};${jump}`;\n  }\n\n  return instruction;\n}\n\nfunction aInstruction(op: number): string {\n  return \"@\" + (op & 0x7fff).toString(10);\n}\n\nexport function op(asm: string): number {\n  if (asm[0] === \"@\") {\n    return aop(asm);\n  } else {\n    return cop(asm);\n  }\n}\n\nfunction aop(asm: string): number {\n  return parseInt(asm.substring(1), 10);\n}\n\nfunction cop(asm: string): number {\n  const parts = asm.match(\n    /(?:(?<assign>[AMD]{1,3})=)?(?<operation>[-!01ADM&|]{1,3})(?:;(?<jump>JGT|JLT|JGE|JLE|JEQ|JMP))?/\n  );\n  const { assign, operation, jump } = parts?.groups ?? {};\n  const mode = operation.includes(\"M\") || assign.includes(\"M\");\n  const aop = ASSIGN.asm[(assign as ASSIGN_ASM) ?? \"\"];\n  const jop = JUMP.asm[(jump as JUMP_ASM) ?? \"\"];\n  const cop = COMMANDS.asm[(operation as COMMANDS_ASM) ?? \"\"];\n\n  return makeC(mode, cop, aop, jop);\n}\n\nexport function makeC(\n  isM: boolean,\n  op: COMMANDS_OP,\n  assign: ASSIGN_OP = 0,\n  jmp: JUMP_OP = 0\n): number {\n  const C = 0xe000;\n  const A = isM ? 0x1000 : 0;\n  const O = op << 6;\n  const D = (assign ?? 0) << 3;\n  const J = jmp ?? 0;\n  return C + A + O + D + J;\n}\n","const Hex = [\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n];\n\nexport function chars(i: number): string {\n  return Hex[i] ?? \"X\";\n}\n\nexport function bits(i: number): string {\n  switch (i) {\n    case 0x0:\n      return \"0000\";\n    case 0x1:\n      return \"0001\";\n    case 0x2:\n      return \"0010\";\n    case 0x3:\n      return \"0011\";\n    case 0x4:\n      return \"0100\";\n    case 0x5:\n      return \"0101\";\n    case 0x6:\n      return \"0110\";\n    case 0x7:\n      return \"0111\";\n    case 0x8:\n      return \"1000\";\n    case 0x9:\n      return \"1001\";\n    case 0xa:\n      return \"1010\";\n    case 0xb:\n      return \"1011\";\n    case 0xc:\n      return \"1100\";\n    case 0xd:\n      return \"1101\";\n    case 0xe:\n      return \"1110\";\n    case 0xf:\n      return \"1111\";\n    default:\n      return \"erro\";\n  }\n}\n\nexport function int(n: string, radix: number): number {\n  const i = parseInt(n.replace(/[^\\d a-f A-F +-.]/g, \"\"), radix);\n  return i & 0xffff;\n}\n\nexport function int16(i: string): number {\n  return int(i, 16);\n}\n\nexport function int10(i: string): number {\n  return int(i, 10);\n}\n\nexport function int2(i: string): number {\n  return int(i.replaceAll(\" \", \"\"), 2);\n}\n\nexport function parseTwosInt(i: string): number {\n  if (i.toUpperCase().includes(\"X\")) {\n    return int16(i);\n  }\n  return int10(i);\n}\n\nexport function hex(i: number): string {\n  const hu = chars((i & 0xf000) >> 12);\n  const hl = chars((i & 0x0f00) >> 8);\n  const lu = chars((i & 0x00f0) >> 4);\n  const ll = chars(i & 0x000f);\n\n  return `0x${hu}${hl}${lu}${ll}`;\n}\n\nexport function bin(i: number, precision = 16): string {\n  const hu = bits((i & 0xf000) >> 12);\n  const hl = bits((i & 0x0f00) >> 8);\n  const lu = bits((i & 0x00f0) >> 4);\n  const ll = bits(i & 0x000f);\n\n  // return `${hu} ${hl} ${lu} ${ll}`;\n  return `${hu}${hl}${lu}${ll}`.substring(16 - precision); // Match the book's formatting\n}\n\nexport function dec(i: number): string {\n  i = i & 0xffff;\n  if (i === 0x8000) {\n    return \"-32768\";\n  }\n  if (i & 0x8000) {\n    i = (~i + 1) & 0x7fff;\n    return `-${i}`;\n  }\n  return `${i}`;\n}\n\nexport function uns(i: number): string {\n  i = i & 0xffff;\n  return `${i}`;\n}\n\nexport function nand16(a: number, b: number): number {\n  a = a & 0xffff;\n  b = b & 0xffff;\n  let c = ~(a & b);\n  c = c & 0xffff;\n  return c;\n}\n","import { RAM } from \"../cpu/memory.js\";\nimport { VmFrame, Segment } from \"./vm.js\";\n\nexport const SP = 0;\nexport const LCL = 1;\nexport const ARG = 2;\nexport const THIS = 3;\nexport const THAT = 4;\nexport const TEMP = 5;\nexport const STATIC = 16;\n\nexport class VmMemory extends RAM {\n  strict = true;\n  get SP(): number {\n    return this.get(SP);\n  }\n  set SP(value: number) {\n    this.set(SP, value);\n  }\n  get LCL(): number {\n    return this.get(LCL);\n  }\n  set LCL(value: number) {\n    this.set(LCL, value);\n  }\n  get ARG(): number {\n    return this.get(ARG);\n  }\n  set ARG(value: number) {\n    this.set(ARG, value);\n  }\n  get THIS(): number {\n    return this.get(THIS);\n  }\n  set THIS(value: number) {\n    this.set(THIS, value);\n  }\n  get THAT(): number {\n    return this.get(THAT);\n  }\n  set THAT(value: number) {\n    this.set(THAT, value);\n  }\n\n  get statics() {\n    const statics = [];\n    for (let i = 16; i < 256; i++) {\n      statics.push(this.get(i));\n    }\n    return statics;\n  }\n\n  constructor() {\n    super();\n    this.set(SP, 256);\n  }\n\n  baseSegment(segment: Segment, offset: number): number {\n    switch (segment) {\n      case \"argument\":\n        return this.ARG + offset;\n      case \"constant\":\n        return offset;\n      case \"local\":\n        return this.LCL + offset;\n      case \"pointer\":\n        return this.pointer(offset);\n      case \"static\":\n        return 16 + offset;\n      case \"temp\":\n        return 5 + offset;\n      case \"that\":\n        return this.THAT + offset;\n      case \"this\":\n        return this.THIS + offset;\n    }\n  }\n\n  getSegment(segment: Segment, offset: number): number {\n    if (segment === \"constant\") return offset;\n    const base = this.baseSegment(segment, offset);\n    return this.get(base);\n  }\n  setSegment(segment: Segment, offset: number, value: number) {\n    const base = this.baseSegment(segment, offset);\n    this.set(base, value);\n  }\n\n  argument(offset: number): number {\n    if (this.strict && offset < 0)\n      throw new Error(`Cannot access negative offsets: ${offset}`);\n    return this.get(this.ARG + offset);\n  }\n  local(offset: number): number {\n    if (this.strict && offset < 0)\n      throw new Error(`Cannot access negative offsets: ${offset}`);\n    return this.get(this.LCL + offset);\n  }\n  static(offset: number): number {\n    if (this.strict && offset < 0)\n      throw new Error(`Cannot access negative offsets: ${offset}`);\n    if (this.strict && offset > 255 - 16)\n      throw new Error(`Cannot access statics beyond 239: ${offset}`);\n    return this.get(16 + offset);\n  }\n  constant(offset: number): number {\n    return offset;\n  }\n  this(offset: number): number {\n    if (this.strict && offset < 0)\n      throw new Error(`Cannot access negative offsets: ${offset}`);\n    return this.get(this.THIS + offset);\n  }\n  that(offset: number): number {\n    if (this.strict && offset < 0)\n      throw new Error(`Cannot access negative offsets: ${offset}`);\n    return this.get(this.THAT + offset);\n  }\n  pointer(offset: number): number {\n    if (this.strict && offset < 0)\n      throw new Error(`Cannot access negative offsets: ${offset}`);\n    if (this.strict && offset > 1)\n      throw new Error(\n        `pointer out of bounds access (pointer can be 0 for this, 1 for that, but got ${offset}`\n      );\n    return offset === 0 ? THIS : THAT;\n  }\n  temp(offset: number): number {\n    if (this.strict && offset < 0)\n      throw new Error(`Cannot access negative offsets: ${offset}`);\n    if (this.strict && offset > 7)\n      throw new Error(\n        `Temp out of bounds access (temp can be 0 to 7, but got ${offset}`\n      );\n    return this.get(5 + offset);\n  }\n\n  push(value: number) {\n    const sp = this.SP;\n    this.set(sp, value);\n    this.set(0, sp + 1);\n  }\n  pop(): number {\n    if (this.strict && this.SP === 256)\n      throw new Error(`Cannot pop the stack below 256 in strict mode`);\n    this.set(0, this.SP - 1);\n    const value = this.get(this.SP);\n    return value;\n  }\n  // Stack frame, from figure 8.3, is:\n  // [ARG] Arg0 Arg1... RET LCL ARG THIS THAT [LCL] Local0 Local1... [SP]\n  pushFrame(ret: number, nArgs: number, nLocals: number): number {\n    const base = this.SP;\n    const arg = base - nArgs;\n    this.set(base, ret);\n    this.set(base + 1, this.LCL);\n    this.set(base + 2, this.ARG);\n    this.set(base + 3, this.THIS);\n    this.set(base + 4, this.THAT);\n\n    this.set(ARG, arg);\n    this.set(LCL, base + 5);\n\n    const sp = base + 5;\n    // Technically this happens in the function, but the VM will handle it for free\n    for (let i = 0; i < nLocals; i++) {\n      this.set(sp + 1, 0);\n    }\n    this.set(SP, sp + nLocals);\n    return base;\n  }\n\n  popFrame(): number {\n    const frame = this.LCL;\n    const ret = this.get(frame - 5);\n    const value = this.pop();\n    this.set(this.ARG, value);\n    this.set(SP, this.ARG + 1);\n    this.set(THAT, this.get(frame - 1));\n    this.set(THIS, this.get(frame - 2));\n    this.set(ARG, this.get(frame - 3));\n    this.set(LCL, this.get(frame - 4));\n    return ret;\n  }\n\n  getFrame(\n    base: number, // The address of the frame, the RET address\n    argN: number, // The number of arguments to this frame\n    localN: number, // The number of locals in this frame\n    thisN: number, // The number of items in `this`\n    thatN: number, // the number of items in `that`\n    nextFrame: number\n  ): VmFrame {\n    const arg = base - argN;\n    const lcl = base + 5;\n    const stk = lcl + localN;\n    const stackN = nextFrame - stk;\n    const args = [...this.map((_, v) => v, arg, arg + argN)];\n    const locals = [...this.map((_, v) => v, lcl, lcl + localN)];\n    const stack = [...this.map((_, v) => v, stk, stk + stackN)];\n    const this_ = [...this.map((_, v) => v, this.THIS, this.THIS + thisN)];\n    const that = [...this.map((_, v) => v, this.THIS, this.THIS + thatN)];\n    return {\n      args: { base: arg, count: argN, values: args },\n      locals: { base: lcl, count: localN, values: locals },\n      stack: { base: stk, count: stackN, values: stack },\n      this: { base: stk, count: thisN, values: this_ },\n      that: { base: stk, count: thatN, values: that },\n      frame: {\n        RET: this.get(base),\n        LCL: this.LCL,\n        ARG: this.ARG,\n        THIS: this.THIS,\n        THAT: this.THAT,\n      },\n    };\n  }\n\n  getVmState(staticN = 240) {\n    const temps = [...this.map((_, v) => v, 5, 13)];\n    const internal = [...this.map((_, v) => v, 13, 16)];\n    const statics = [...this.map((_, v) => v, 16, 16 + staticN)];\n    return {\n      [\"0: SP\"]: this.SP,\n      [\"1: LCL\"]: this.LCL,\n      [\"2: ARG\"]: this.ARG,\n      [\"3: THIS\"]: this.THIS,\n      [\"4: THAT\"]: this.THAT,\n      temps,\n      internal,\n      static: statics,\n    };\n  }\n\n  binOp(fn: (a: number, b: number) => number) {\n    const a = this.get(this.SP - 2);\n    const b = this.get(this.SP - 1);\n    const v = fn(a, b) & 0xffff;\n    this.set(this.SP - 2, v);\n    this.set(SP, this.SP - 1);\n  }\n  unOp(fn: (a: number) => number) {\n    const a = this.get(this.SP - 1);\n    const v = fn(a) & 0xffff;\n    this.set(this.SP - 1, v);\n  }\n  comp(fn: (a: number, b: number) => boolean) {\n    this.binOp((a, b) => (fn(a, b) ? -1 : 0));\n  }\n}\n","import {\n  Err,\n  Ok,\n  Result,\n  isErr,\n  unwrap,\n} from \"@davidsouther/jiffies/lib/esm/result.js\";\nimport { FunctionInstruction, VmInstruction } from \"../languages/vm.js\";\nimport { VmMemory } from \"./memory.js\";\nimport { MemoryAdapter, RAM } from \"../cpu/memory.js\";\n\nexport type VmOperation =\n  | FunctionOperation\n  | StackOperation\n  | OpOperation\n  | CallOperation\n  | ReturnOperation\n  | GotoOperation\n  | LabelOperation;\n\nexport type Segment =\n  | \"argument\"\n  | \"local\"\n  | \"static\"\n  | \"constant\"\n  | \"this\"\n  | \"that\"\n  | \"pointer\"\n  | \"temp\";\n\nexport type BinOp = \"add\" | \"sub\" | \"and\" | \"or\";\nexport type CmpOp = \"lt\" | \"gt\" | \"eq\";\nexport type UnOp = \"neg\" | \"not\";\nexport type Op = BinOp | CmpOp | UnOp;\n\nexport interface FunctionOperation {\n  op: \"function\";\n  name: string;\n  nVars: number;\n}\n\nexport interface StackOperation {\n  op: \"push\" | \"pop\";\n  segment: Segment;\n  offset: number;\n}\nexport interface OpOperation {\n  op: Op;\n}\nexport interface CallOperation {\n  op: \"call\";\n  name: string;\n  nArgs: number;\n}\nexport interface ReturnOperation {\n  op: \"return\";\n}\nexport interface LabelOperation {\n  op: \"label\";\n  label: string;\n}\nexport interface GotoOperation {\n  op: \"goto\" | \"if-goto\";\n  label: string;\n}\n\ninterface VmFrameValues {\n  base: number;\n  count: number;\n  values: number[];\n}\n\nexport interface VmFrame {\n  fn?: VmFunction;\n  locals: VmFrameValues;\n  args: VmFrameValues;\n  stack: VmFrameValues;\n  this: VmFrameValues;\n  that: VmFrameValues;\n  frame: {\n    RET: number;\n    ARG: number;\n    LCL: number;\n    THIS: number;\n    THAT: number;\n  };\n}\n\nexport type VmFunctions = Record<string, VmFunction>;\nexport interface VmFunction {\n  name: string;\n  nVars: number;\n  labels: Record<string, number>;\n  operations: VmOperation[];\n  opBase: number;\n}\n\ninterface VmFunctionInvocation {\n  function: string;\n  // The current operation offset in the function\n  opPtr: number;\n  // Base address of the frame in memory\n  frameBase: number;\n  // The number of args the function was called with\n  nArgs: number;\n}\n\nconst IMPLICIT: VmFunction = {\n  name: \"__implicit\",\n  nVars: 0,\n  opBase: 0,\n  labels: {},\n  operations: [{ op: \"function\", name: \"__implicit\", nVars: 0 }],\n};\n\nconst BOOTSTRAP: VmFunction = {\n  name: \"__bootstrap\",\n  nVars: 0,\n  opBase: 0,\n  labels: {},\n  operations: [\n    { op: \"function\", name: \"__bootstrap\", nVars: 0 },\n    { op: \"call\", name: \"Sys.init\", nArgs: 0 },\n  ],\n};\n\nfunction BootstrapFor(name: string): VmFunction {\n  return {\n    name: \"__bootstrap\",\n    nVars: 0,\n    opBase: 0,\n    labels: {},\n    operations: [\n      { op: \"function\", name: \"__bootstrap\", nVars: 0 },\n      { op: \"call\", name, nArgs: 0 },\n    ],\n  };\n}\n\nconst END_LABEL = \"__END\";\nconst SYS_INIT: VmFunction = {\n  name: \"Sys.init\",\n  labels: { END: 1 },\n  nVars: 0,\n  opBase: 0,\n  operations: [\n    { op: \"call\", name: \"main\", nArgs: 0 },\n    { op: \"label\", label: END_LABEL },\n    { op: \"goto\", label: END_LABEL },\n  ],\n};\n\nexport class Vm {\n  memory = new VmMemory();\n  entry = \"\";\n  functionMap: Record<string, VmFunction> = {};\n  executionStack: VmFunctionInvocation[] = [];\n\n  functions: VmFunction[] = [];\n  program: VmOperation[] = [];\n\n  private staticCount = 0;\n  protected statics: Record<string, number[]> = {};\n\n  private registerStatic(fnName: string, offset: number): number {\n    const fileName = fnName.split(\".\")[0];\n    const statics = this.statics[fileName] ?? [];\n    this.statics[fileName] = statics;\n    const static_ = statics[offset] ?? this.staticCount++;\n    statics[offset] = static_;\n    return static_;\n  }\n\n  private registerStatics() {\n    for (const fn of Object.values(this.functionMap)) {\n      for (const op of fn.operations) {\n        if (\n          [\"push\", \"pop\"].includes(op.op) &&\n          (op as { segment: string }).segment === \"static\"\n        ) {\n          (op as { offset: number }).offset = this.registerStatic(\n            fn.name,\n            (op as { offset: number }).offset\n          );\n        }\n      }\n    }\n  }\n\n  static build(instructions: VmInstruction[]): Result<Vm> {\n    const vm = new Vm();\n    const load = vm.load(instructions);\n    if (isErr(load)) return load;\n    return vm.bootstrap();\n  }\n\n  private static buildFunction(\n    instructions: VmInstruction[],\n    i: number\n  ): Result<[VmFunction, number]> {\n    if (instructions[i].op !== \"function\")\n      return Err(\n        Error(\"Only call buildFunction at the initial Function instruction\")\n      );\n\n    const { name, nVars } = instructions[i] as FunctionInstruction;\n    const fn: VmFunction = {\n      name,\n      nVars,\n      labels: {},\n      operations: [{ op: \"function\", name, nVars }],\n      opBase: 0,\n    };\n\n    i += 1;\n    instructions: while (i < instructions.length) {\n      switch (instructions[i].op) {\n        case \"function\":\n          break instructions;\n        case \"add\":\n        case \"sub\":\n        case \"neg\":\n        case \"and\":\n        case \"or\":\n        case \"not\":\n        case \"gt\":\n        case \"lt\":\n        case \"eq\":\n          fn.operations.push({\n            op: instructions[i].op as\n              | \"add\"\n              | \"sub\"\n              | \"neg\"\n              | \"lt\"\n              | \"gt\"\n              | \"eq\"\n              | \"and\"\n              | \"or\"\n              | \"not\",\n          });\n          break;\n        case \"push\":\n        case \"pop\":\n          fn.operations.push({\n            op: instructions[i].op as \"push\" | \"pop\",\n            segment: (\n              instructions[i] as {\n                segment:\n                  | \"argument\"\n                  | \"local\"\n                  | \"static\"\n                  | \"constant\"\n                  | \"this\"\n                  | \"that\"\n                  | \"pointer\"\n                  | \"temp\";\n              }\n            ).segment,\n            offset: (instructions[i] as { offset: number }).offset,\n          });\n          break;\n        case \"call\":\n          fn.operations.push({\n            op: \"call\",\n            name: (instructions[i] as { name: string }).name,\n            nArgs: (instructions[i] as { nArgs: number }).nArgs,\n          });\n          break;\n        case \"goto\":\n        case \"if-goto\":\n          fn.operations.push({\n            op: instructions[i].op as \"goto\" | \"if-goto\",\n            label: (instructions[i] as { label: string }).label,\n          });\n          break;\n        case \"label\": {\n          const { label } = instructions[i] as { label: string };\n          if (fn.labels[label])\n            throw new Error(\n              `Cannot redeclare label ${label} in function ${fn.name} (previously at ${fn.labels[label]})`\n            );\n          fn.labels[label] = fn.operations.length;\n          fn.operations.push({ op: \"label\", label });\n          break;\n        }\n        case \"return\": {\n          fn.operations.push({ op: \"return\" });\n          break;\n        }\n      }\n\n      i += 1;\n    }\n\n    if (fn.name === IMPLICIT.name) {\n      fn.labels[END_LABEL] = fn.operations.length;\n      fn.operations.push({ op: \"label\", label: END_LABEL });\n      fn.operations.push({ op: \"goto\", label: END_LABEL });\n    }\n\n    return Ok([fn, i]);\n  }\n\n  get RAM(): RAM {\n    return this.memory;\n  }\n\n  get Keyboard(): MemoryAdapter {\n    return this.memory.keyboard;\n  }\n  get Screen(): MemoryAdapter {\n    return this.memory.screen;\n  }\n\n  get invocation() {\n    const invocation = this.executionStack.at(-1);\n    if (invocation === undefined) {\n      throw new Error(\"Empty execution stack!\");\n    }\n    return invocation;\n  }\n\n  get currentFunction() {\n    const fn = this.functionMap[this.invocation.function];\n    if (fn === undefined)\n      throw new Error(\n        `Executing undefined function ${this.invocation.function}`\n      );\n    return fn;\n  }\n\n  get operation() {\n    if (this.invocation.opPtr > this.currentFunction.operations.length)\n      throw new Error(\n        `Current operation step beyond end of function operations (${this.invocation.opPtr} > ${this.currentFunction.operations.length})`\n      );\n\n    return this.currentFunction.operations[this.invocation.opPtr];\n  }\n\n  load(instructions: VmInstruction[]): Result<this, Error> {\n    if (instructions[0]?.op !== \"function\") {\n      instructions.unshift({ op: \"function\", name: IMPLICIT.name, nVars: 0 });\n    }\n\n    let i = 0;\n    while (i < instructions.length) {\n      const buildFn = Vm.buildFunction(instructions, i);\n\n      if (isErr(buildFn))\n        return Err(new Error(\"Failed to build VM\", { cause: Err(buildFn) }));\n      const [fn, i_] = unwrap(buildFn);\n      if (\n        this.functionMap[fn.name] &&\n        this.memory.strict &&\n        fn.name !== IMPLICIT.name\n      ) {\n        return Err(new Error(`VM Already has a function named ${fn.name}`));\n      }\n\n      this.functionMap[fn.name] = fn;\n      i = i_;\n    }\n\n    this.registerStatics();\n\n    return Ok(this);\n  }\n\n  bootstrap() {\n    if (!this.functionMap[SYS_INIT.name] && this.functionMap[\"main\"]) {\n      this.functionMap[SYS_INIT.name] = SYS_INIT;\n      // TODO should this be an error from the compiler/OS?\n    }\n\n    if (this.functionMap[SYS_INIT.name]) {\n      this.functionMap[BOOTSTRAP.name] = BootstrapFor(SYS_INIT.name);\n      this.entry = BOOTSTRAP.name;\n    } else if (this.functionMap[IMPLICIT.name]) {\n      this.entry = IMPLICIT.name;\n    } else {\n      const fnNames = Object.keys(this.functionMap);\n      if (fnNames.length === 1) {\n        this.functionMap[BOOTSTRAP.name] = BootstrapFor(fnNames[0]);\n        this.entry = BOOTSTRAP.name;\n      }\n    }\n\n    if (this.functionMap[IMPLICIT.name] && this.functionMap[BOOTSTRAP.name]) {\n      return Err(\n        new Error(\"Cannot use both bootstrap and an implicit function\")\n      );\n    }\n\n    if (this.entry === \"\") {\n      return Err(Error(\"Could not determine an entry point for VM\"));\n    }\n\n    this.functions = Object.values(this.functionMap);\n    this.functions.sort((a, b) => {\n      if (a.name === this.entry) return -1;\n      if (a.name === this.entry) return 1;\n      return 0; // Stable sort otherwise\n    });\n\n    let offset = 0;\n    this.program = this.functions.reduce((prog, fn) => {\n      fn.opBase = offset;\n      offset += fn.operations.length;\n      return prog.concat(fn.operations);\n    }, [] as VmOperation[]);\n\n    this.reset();\n\n    return Ok(this);\n  }\n\n  reset() {\n    this.executionStack = [\n      { function: this.entry, opPtr: 1, frameBase: 256, nArgs: 0 },\n    ];\n    this.memory.reset();\n    this.memory.set(0, 256);\n  }\n\n  step() {\n    const operation = this.operation ?? { op: \"return\" }; // Implicit return if the function doesn't end on its own.\n    switch (operation.op) {\n      case \"push\": {\n        const value = this.memory.getSegment(\n          operation.segment,\n          operation.offset\n        );\n        this.memory.push(value);\n        break;\n      }\n      case \"pop\": {\n        const value = this.memory.pop();\n        this.memory.setSegment(operation.segment, operation.offset, value);\n        break;\n      }\n      case \"add\": {\n        this.memory.binOp((a, b) => a + b);\n        break;\n      }\n      case \"sub\": {\n        this.memory.binOp((a, b) => a - b);\n        break;\n      }\n      case \"neg\": {\n        // neg by flipping the sign bit\n        this.memory.unOp((a) => -a);\n        break;\n      }\n      case \"and\": {\n        this.memory.binOp((a, b) => a & b);\n        break;\n      }\n      case \"or\": {\n        this.memory.binOp((a, b) => a | b);\n        break;\n      }\n      case \"not\": {\n        this.memory.unOp((a) => ~a);\n        break;\n      }\n      case \"eq\": {\n        this.memory.comp((a, b) => a === b);\n        break;\n      }\n      case \"lt\": {\n        this.memory.comp((a, b) => a < b);\n        break;\n      }\n      case \"gt\": {\n        this.memory.comp((a, b) => a > b);\n        break;\n      }\n      case \"goto\": {\n        this.goto(operation.label);\n        break;\n      }\n      case \"if-goto\": {\n        const check = this.memory.pop();\n        if (check != 0) {\n          this.goto(operation.label);\n        }\n        break;\n      }\n      case \"call\": {\n        const fnName = operation.name;\n        const fn = this.functionMap[fnName];\n        if (!fn) throw new Error(`Calling unknown function ${fnName}`);\n        const base = this.memory.pushFrame(\n          this.invocation.opPtr,\n          operation.nArgs,\n          fn.nVars\n        );\n        this.executionStack.push({\n          function: fnName,\n          opPtr: 0,\n          nArgs: operation.nArgs,\n          frameBase: base,\n        });\n        break;\n      }\n      case \"return\": {\n        this.executionStack.pop();\n        const ret = this.memory.popFrame();\n        this.invocation.opPtr = ret;\n        break;\n      }\n      case \"label\": {\n        // noop\n        break;\n      }\n    }\n    this.invocation.opPtr += 1;\n  }\n\n  private goto(label: string) {\n    if (this.currentFunction.labels[label] === undefined)\n      throw new Error(\n        `Attempting GOTO to unknown label ${label} in ${this.currentFunction.name}`\n      );\n    this.invocation.opPtr = this.currentFunction.labels[label];\n  }\n\n  write(addresses: [number, number][]) {\n    addresses.map(([address, value]) => {\n      this.memory.set(address, value);\n    });\n  }\n\n  read(addresses: number[]): number[] {\n    return addresses.map((address) => this.memory.get(address));\n  }\n\n  vmStack(): VmFrame[] {\n    return this.executionStack.map((invocation, i) => {\n      const next = this.executionStack[i + 1];\n      const end = next ? next.frameBase - next.nArgs : this.memory.get(0);\n      return this.makeFrame(invocation, end);\n    });\n  }\n\n  makeFrame(invocation = this.invocation, nextFrame: number): VmFrame {\n    const fn = this.functionMap[invocation.function];\n    if ([\"__implicit\", \"__bootstrap\"].includes(fn.name)) {\n      // top most frame is \"special\"\n      const frameBase = 256;\n      const nextFrame = this.executionStack[1];\n      const frameEnd = nextFrame\n        ? nextFrame.frameBase - nextFrame.nArgs\n        : this.memory.get(0);\n      return {\n        fn,\n        args: { base: 256, count: 0, values: [] },\n        locals: { base: 256, count: 0, values: [] },\n        stack: {\n          base: 256,\n          count: frameEnd - frameBase,\n          values: [...this.memory.map((_, v) => v, frameBase, frameEnd)],\n        },\n        [\"this\"]: { base: 0, count: 0, values: [] },\n        that: { base: 0, count: 0, values: [] },\n        frame: {\n          ARG: 0,\n          LCL: 0,\n          RET: 0,\n          THAT: 0,\n          THIS: 0,\n        },\n      };\n    }\n    const frame = this.memory.getFrame(\n      invocation.frameBase,\n      invocation.nArgs,\n      fn.nVars,\n      0,\n      0,\n      nextFrame\n    );\n    frame.fn = fn;\n    return frame;\n  }\n\n  derivedLine(): number {\n    return this.currentFunction.opBase + this.invocation.opPtr;\n  }\n\n  writeDebug(): string {\n    const line = this.derivedLine();\n    const from = Math.max(line - 5, 0);\n    const to = Math.min(line + 3, this.program.length);\n    const lines = this.program.slice(from, to);\n    const prog = lines\n      .map((op, i) => `${i === line - from ? \"->\" : \"  \"} ${writeOp(op)}`)\n      .join(\"\\n\");\n    const frame = this.vmStack().at(-1);\n    if (frame) {\n      return prog + \"\\n\\n\" + writeFrame(frame);\n    }\n    return prog;\n  }\n}\n\nexport function writeFrame(frame: VmFrame): string {\n  return [\n    `Frame: ${frame.fn?.name ?? \"Unknown Fn\"} ARG:${frame.frame.ARG} LCL:${\n      frame.frame.LCL\n    }`,\n    `Args: ${writeFrameValues(frame.args)}`,\n    `Lcls: ${writeFrameValues(frame.locals)}`,\n    `Stck: ${writeFrameValues(frame.stack)}`,\n  ].join(\"\\n\");\n}\n\nfunction writeFrameValues(fv: VmFrameValues): string {\n  return `[${fv.base};${fv.count}][${fv.values.join(\", \")}]`;\n}\n\nfunction writeOp(op: VmOperation): string {\n  switch (op.op) {\n    case \"add\":\n    case \"and\":\n    case \"sub\":\n    case \"eq\":\n    case \"gt\":\n    case \"lt\":\n    case \"neg\":\n    case \"not\":\n    case \"or\":\n    case \"return\":\n      return `  ${op.op}`;\n    case \"goto\":\n      return `  ${op.op}    ${op.label}`;\n    case \"if-goto\":\n      return `  ${op.op} ${op.label}`;\n    case \"label\":\n      return `${op.op}     ${op.label}`;\n    case \"call\":\n      return `  ${op.op}    ${op.name} ${op.nArgs}`;\n    case \"function\":\n      return `${op.op}  ${op.name} ${op.nVars}`;\n    case \"pop\":\n      return `  ${op.op}     ${op.segment} ${op.offset}`;\n    case \"push\":\n      return `  ${op.op}    ${op.segment} ${op.offset}`;\n  }\n}\n"],"names":["DiffTable","className","out","cmp","zeroState","output","CMP","compare","isErr","_jsxs","children","_jsx","display","Err","cmpData","Ok","outData","failures","table","range","Math","min","length","map","i","cmpI","outI","max","_","j","cell","pass","trim","match","style","fontFamily","marginBottom","row","DiffCell","HIGH","LOW","Bus","name","width","this","state","newWidth","assert","next","push","busVoltage","voltage","bit","forEach","n","pull","reduce","b","nextVoltage","InSubBus","bus","start","connect","mask","high","low","mid","OutSubBus","ConstantBus","value","TRUE_BUS","FALSE_BUS","parsePinDecl","toPin","groups","pin","w","Number","Symbol","iterator","Pins","Map","has","set","minWidth","get","insert","values","id","Chip","ins","outs","internals","clocked","Set","inn","undefined","internal","pins","clockedPins","Clock","$","subscribe","eval","size","parts","reset","hasIn","hasOut","offset","getBuiltin","BUILTIN_NAMES","includes","part","connections","add","to","from","isOutPin","wireOutPin","wireInPin","toLowerCase","emplace","partPin","assertExists","chipPin","findPin","isInternal","Error","ensureWidth","chip","remove","fs","path","load","Low","ClockedChip","level","tock","tick","unsubscribe","pow","clock","BehaviorSubject","ticks","Subject","subject","frameSubject","resetSubject","COMMANDS_ALU","op","COMMANDS","asm","D","A","M","ASSIGN","MD","AM","AD","AMD","JUMP","JGT","JEQ","JGE","JLT","JNE","JLE","JMP","Flags","Positive","Zero","Negative","alu","d","a","o","emptyState","PC","ALU","flag","BITS","decode","instruction","c","x1","x2","am","d1","d2","d3","j1","j2","j3","cpuTick","inM","bits","cpuTock","alu2","addressM","outM","writeM","CPU","RAM","RAMMem","ROM","Screen","SubMemory","SCREEN_SIZE","SCREEN_OFFSET","Keyboard","MemoryKeyboard","input","tickState","cpu","FORMATS","SCREEN_ROWS","KEYBOARD_OFFSET","Memory","memory","Int16Array","index","fill","format","current","int2","int16","int10","isFinite","loadBytes","bytes","end","slice","fn","v","parent","update","key","program","arr","SIZE","endsWith","loadHack","loadAsm","loader","readFile","UNKNOWN_PARSE_ERROR","grammars","Base","ohm","baseSemantics","createSemantics","makeParser","grammar","semantics","property","root","source","succeeded","parsed","parse","message","shortMessage","e","extendOperation","List","list","asIteration","addAttribute","decNumber","digits","sourceString","wholeDec","binNumber","hexNumber","num","Name","ident","identifier","__","child","String","_a","str","_b","cmpGrammar","cmpSemantics","extendSemantics","line","cells","Root","lines","parser","tstGrammar","tstSemantics","extendAttribute","Index","idx","FileName","_open","dec","_close","OutputFormat","_c","lpad","rpad","builtin","address","TstEvalOperation","TstOutputOperation","TstOutputListOperation","formats","spec","TstSetOperation","setOp","TstEchoOperation","TstClearEchoOperation","TstLoadROMOperation","_r","_l","file","TstFileOperation","Condition","left","right","TstWhile","cond","_o","statements","statement","condition","span","startIdx","endIdx","TstRepeat","count","TstStatement","stmt","ops","node","operation","break","Tst","tst","TST","vmGrammar","vmSemantics","Push","Pop","Function","Call","Return","Goto","IfGoto","Label","Add","Sub","Neg","Eq","Lt","Gt","And","Or","Not","Argument","Local","Static","Constant","This","That","Pointer","Temp","StackInstruction","segment","OpInstruction","FunctionInstruction","nVars","CallInstruction","nArgs","ReturnInstruction","LabelInstruction","label","GotoInstruction","Vm","instructions","vm","VM","asmGrammar","asmSemantics","isALabelInstruction","inst","AInstruction","_at","val","type","CInstruction","assignN","opN","jmpN","assign","replace","jmp","isM","jump","store","asmToInt","makeC","C","ASM","passes","fillLabel","nextLabel","symbols","unfilled","emit","filter","AC","L","unwrap","split","loadBlob","parseTwosInt","Output","variable","len","lPad","rPad","startsWith","fmt","parseInt","test","substring","padCenter","getVar","padLeft","B","bin","X","hex","padRight","space","leftSpace","floor","rightSpace","padStart","padEnd","TestSetInstruction","setVar","TestOutputInstruction","TestOutputListInstruction","specs","addOutput","outputs","outputList","header","TestCompoundInstruction","do","_test","TestRepeatInstruction","repeat","steps","innerSteps","x","y","hasVar","TestWhileInstruction","check","TestEchoInstruction","content","echo","TestClearEchoInstruction","clearEcho","TestLoadROMInstruction","pushd","popd","isTstLineStatment","isTstWhileStatement","makeLineStatement","makeInstruction","addInstruction","TestTickInstruction","TestTockInstruction","TestTickTockInstruction","TestEvalInstruction","TestVMStepInstruction","checkExhaustive","ChipTest","toString","pinOrBus","filename","Test","CPUTest","rom","setA","setD","setPC","ticktock","FileSystem","_content","_filename","_outputList","_steps","_step","_log","done","step","breakpoints","clear","print","join","VMTest","getSegment","setSegment","SP","ARG","LCL","THIS","THAT","scandir","isFile","bootstrap","vmstep","mop","cop","sop","jop","command","cInstruction","aInstruction","aop","mode","O","J","Hex","chars","int","radix","replaceAll","toUpperCase","hu","hl","lu","ll","precision","uns","nand16","VmMemory","statics","pointer","base","baseSegment","strict","sp","ret","nLocals","arg","frame","pop","argN","localN","thisN","thatN","nextFrame","lcl","stk","stackN","args","locals","stack","that","RET","staticN","temps","binOp","IMPLICIT","BOOTSTRAP","BootstrapFor","opBase","labels","operations","END_LABEL","SYS_INIT","END","fnName","fileName","static_","staticCount","Object","functionMap","registerStatic","keyboard","screen","invocation","executionStack","at","function","opPtr","currentFunction","unshift","buildFn","buildFunction","cause","i_","registerStatics","entry","fnNames","keys","functions","sort","prog","concat","frameBase","unOp","comp","goto","pushFrame","popFrame","addresses","makeFrame","frameEnd","getFrame","derivedLine","writeOp","vmStack","writeFrameValues","writeFrame","fv"],"sourceRoot":""}